# HTML

## 必考：你是如何理解 HTML 语义化的？

什么是html语义化：语义化的标签，让标签有自己的含义

语义化的特点：

1. 代码结构清晰，方便阅读
2. 方便设备解析，以语义化的方式来渲染网页
3. 有利于搜索引擎优化（SEO）

举例：

1. <hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。

2. <article>文档中定义文章内容 <aside>  <details> <dialog>  <figcaption> <figure> img和figcaption组合放在figure里  <footer> 一个文档可以有多个footer <header>一个文档可以有多个header  <main> <mark>  <nav> 导航 <section> 在文档中定义部分  <summary> <time>

   

## meta viewport 是做什么用的，怎么写？

1. meta viewport是

## 你用过哪些 HTML 5 标签？

## H5 是什么？

# CSS

## 基础

### 盒模型

- 必考：两种盒模型分别说一下

  标准盒模型：浏览器默认`box-sizing: content-box`

  当我们设置`width`的时候，设置的是盒模型的`content`，此时盒子的实际宽度等于`content(width)+padding+border+magin`

  怪异盒模型：通过设置`box-sizing: boder-box`，此时设置的`width`等于`content+padding+border`

## 布局

### 必考：如何垂直居中？

1. absolute + margin负值

   ```css
   #outer {
       position: relative;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-top: -100px;
       margin-left: -100px;
   }
   ```
   
2. absolute + calc

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       position: relative;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       position: absolute;
       top: calc(50% - 100px);
       left: calc(50% - 100px);
   }
   ```

   **以上两种方法适用于元素已知高宽的情况，若高宽不确定，则不可使用**

3. absolute + transform

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       position: relative;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       position: absolute;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
   }
   ```
   
4. flex

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       display: flex;
       justify-content: center;
       align-item: center;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
   }
   ```

5. flex + margin: auto

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       display: flex;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       margin: auto;
   }
   ```

   

### 必考：flex

老版本：`display: -webkit-box`

新版本：`display: flex` 或 `display: -webkit-flex`

- 容器属性

  ```css
  .flex-container {
      display: flex;
      /* 
      容器的布局方向（主轴是哪一根）
      默认值：row
      属性值：row column
      */
      flex-direction: row;
      
      /*
      容器的排列方向（主轴的方向）
  ```

	 	属性值：row-reverse
	  */
	  flex-direction: row-reverse;
	  
	  /*
	  富裕空间管理（主轴）
	  默认值：flex-start
	  属性值：flex-start（主轴正方向） flex-end（主轴反方向）center（两边） space-between（项目之间） 		space-around（项目两边）
	  */
	  justify-content: flex-start;
	  
	  /*
	  富裕空间管理（侧轴）
	  默认值：flex-start
	  属性值：flex-start strech flex-end center baseline
	  */
	  align-items: flex-start;
	  
	  /*
	  单行、多行显示。多行显示时可以控制堆叠方向
	  默认值：nowrap
	  属性值：nowrap wrap wrap-reverse
	  */
	  flex-wrap: nowrap;
  }
  ```
  
- 项目属性

  ```css
  .flex-item {
      /*
      弹性空间管理
      默认值：0
      */
      flex-grow: 0;
      
      /* 规定项目的顺序，值越大，排列在越后面 */
      order: 1;
  }
  ```

### 三列布局

需求：

1. 左右两列宽度固定，中间自适应
2. 中间列的内容完全显示
3. 中间列优先加载

#### 圣杯布局

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            
        }
        body {
            min-width: 600px;
        }
        #wrap {
            padding: 0 200px;
            height: 300px;
        }
        .left, .right {
            position: relative;
            width: 200px;
            background-color: red;
            float: left;
        }
        .left {
            margin-left: -100%;
            left: -200px;
        }
        .right {
            left: 200px;
            margin-left: -200px;
        }
        .middle {
            background-color: hotpink;
            float: left;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="wrap">
        <div class="middle">middle</div>
        <div class="left">left</div>
        <div class="right">right</div>
    </div>
</body>

</html>
```

#### 双飞翼布局

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            
        }
        body {
            min-width: 600px;
        }
        #wrap {
            height: 300px;
        }
        .left, .right {
            width: 200px;
            background-color: red;
            float: left;
        }
        .left {
            margin-left: -100%;
        }
        .right {
            margin-left: -200px;
        }
        .middle {
            background-color: hotpink;
            float: left;
            width: 100%;
        }
        .inner {
            padding: 0 200px;
        }
    </style>
</head>

<body>
    <div id="wrap">
        <div class="middle">
            <div class="inner">middle</div>
        </div>
        <div class="left">left</div>
        <div class="right">right</div>
    </div>
</body>

</html>
```

#### 伪等高布局

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #wrap {
            width: 750px;
            border: 1px solid black;
            margin: 0 auto;
            overflow: hidden;
        }
        #wrap .left {
            width: 300px;
            background-color: pink;
            float: left;
            padding-bottom: 1000px;
            margin-bottom: -1000px;
        }
        #wrap .right {
            width: 450px;
            background-color: hotpink;
            float: left;
            padding-bottom: 1000px;
            margin-bottom: -1000px;

        }

        .clearfix {
            *zoom: 1;
        }
        .clearfix:after {
            content: "";
            display: block;
            clear: both;
        }
    </style>
</head>

<body>
    <div id="wrap" class="clearfix">
        <div class="left">
            left <br>
        </div>
        <div class="right">
            right <br>
            right <br>
        </div>
    </div>
</body>

</html>
```

### 必考：BFC

#### bfc是什么：Block Formatting Context 块级格式化上下文

bfc是一个盒子，这个盒子的内部布局不受外部影响

#### 何时会触发bfc

- 根元素`html`
- `float`的值不为`none`
- `position`的值不为`relative`和`static`
- `overflow`的值为`auto`,`scroll`或`hidden`
- `display`的值为`table-cell`, `table-caption`, `inline-block`中的任何一个

#### 布局规则

#### 作用

1. 清除浮动

   ```html
   <style>
       .outer {
           <!-- 使用overflow: auto;使outer元素成为BFC（触发outer元素的BFC）-->
           overflow: auto;
       }
       .inner {
           width: 200px;
           height: 200px;
           float: left;
       }
   </style>
   <body>
       <div class='outer'>
           <div class='inner'>
           </div>
       </div>
   </body>
   ```

2. 防止外边距合并： 同属一个BFC的相邻元素会发生外边距（margin）重叠 

   ```html
   <style>
       .upper {
           margin: 20px;
       }
       .lower {
           margin: 20px;
       }
       .bfc {
           overflow: auto;
       }
   </style>
   <div class="upper"></div>
   <div class="bfc">
       <div class="lower">
   
       </div>
   </div>
   ```

3.  阻止元素被浮动元素覆盖

   ```html
   <style>
       .float {
           float: left;
       }
   
       .content {
           overflow: auto;
       }
   </style>
   <div class="float"></div>
   <div class="content"></div>
   ```

1. CSS 选择器优先

## 清除浮动

1. 开启BFC清除浮动（开启BFC后，BFC内部的float元素可以撑开父元素高度）

   ie6没有bfc不支持

2. 添加额外标签应用clear:both

   违反了结构 行为 样式分离的原则

   并且ie6存在最小高度问题

   ```html
   <style>
       .float {
           float: left;
       }
       .clear {
           clear: both;
       }
   </style>
   <div>
       <div class="float">
   
       </div>
       <div class="clear">
   
       </div>
   </div>
   ```

3. ie6需要利用*zoom=1开启haslayout

4. 使用伪元素+clear:both

   ```html
   <style>
       .float {
           float: left;
       }
       .clearfix:after {
           content: "";
           display: block;
           clear: both;
       }
   </style>
   <div class="clearfix">
       <div class="float">
   
       </div>
   </div>
   ```

# 原生 JS

## 必考：ES 6 语法知道哪些，分别怎么用？

let与const命令：

1. 不存在变量提升，变量不可在声明前使用
2. 暂时性死区，在代码块中，使用let声明变量之前，变量都不可用
3. 提供了块级作用域
4. const声明的变量不可改变内存地址，一声明就要初始化

解构赋值：

1. 数组的解构赋值
2. 对象的解构赋值

## 原型链

构造函数 实例 原型的关系

每个构造函数都有一个原型对象`prototype`，原型对象包含一个指向构造函数的指针`constructor`

每个实例都有一个`__proto__`属性，该属性指向构造函数的原型对象

## Generator

​	定义：语法上，可以把generator函数理解为一个状态机，封装了多个内部状态

​	使用：调用Generator函数会返回一个遍历器对象(Iterator Object)

​	

```js
function* helloGenerator() {
    yield 1
    yield 2
    return 3
}
let hw = helloGEnerator()
```

​	遍历器对象上的方法：

​			`hw.next()`  继续执行generator函数

​			`hw.throw()` 在函数体外抛出错误，在函数体内捕获

​			`hw.return()`返回给定的值，并且终结遍历 Generator 函数

## 必考 Promise、Promise.all、Promise.race 分别怎么用？

1. Promise.prototype.then()

2. Promise.prototype.catch()

3. Promise.prototype.finally()

4. Promise.all()

   ​	将多个Promise实例 包装成一个新的Promise实例

   ```js
   const p = Promise.all([p1, p2, p3]);
   ```

   1. 参数：接受一个数组（或具有iterator接口的对象），并且成员都是promise对象作为参数

   2. p的状态由p1 p2 p3决定

      ​	当p1 p2 p3的状态都变成`fulfilled` p的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。

      ​	只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数

5. Promise.race()

   将多个Promise实例 包装秤一个新的Promise实例

   ```js
   const p = Promise.race([p1, p2, p3]);
   ```

   只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给`p`的回调函数

## 必考：手写函数防抖和函数节流

函数防抖：一定时间内，事件连续触发，只执行最后一次

```javascript
function debounce(method, context) {
    clearTimeout(method.timer)
    method.timer = setTimeout(() => {
        method.call(context)
    }, 500)
}
```

函数节流：间隔一段时间执行一次

```javascript
    function throttle(func, wait) {
    let timer
    return () => {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fun()
            timer = null
        }, wait)
    }
}
```



## 必考：手写AJAX

- 回调函数封装

  ```javascript
  const ajax = ({
      method = 'get',
      url = '/',
      async = true,
      data
  } = {}, callback) => {
      let xhr = new XMLHttpRequest()
      xhr.onreadystatechange = () => {
          if (xhr.readyState === 4 && xhr.status === 200) {
              let res = JSON.parse(xhr.responseText)
              callback(res)
          }
      }
      xhr.open(method, url, async)
      if (method === 'get') {
          xhr.send(null)
      }
      if (method === 'post') {
          let type = typeof data
          let header
          if (type === 'string') {
              header = 'application/x-www-form-urlencoded'
          } else {
              header = 'application/json'
              data = JSON.stringify(data)
          }
      }
      xhr.setRequestHeader('Content-type', header)
      xhr.send(data)
  }
  ```

- Promise封装

  ```javascript
  const ajax = ({
      method = 'get',
      url = '/',
      async = true,
      data
  }) => {
      return new Promise((resolve, reject) => {
          let xhr = new XMLHttpRequest()
          xhr.onreadystatechange = () => {
              if (xhr.readyState === 4) {
                  if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                      let res = JSON.parse(xhr.responseText)
                      resolve(res)
                  } else {
                      reject(res.status)
                  }
              }
          }
          xhr.open(method, url, async)
         if (method === 'get') {
             xhr.send(null)
         }
         if (method === 'post') {
             let type = typeof data
             let header
             if (type === 'string') {
                 header = 'application/x-www-form-urlencoded'
             } else {
                 header = 'application/json'
             }
             xhr.setRequestHeader('Content-type', header)
             xhr.send(data)
         }
      })
  }
  
  ajax.get = (url) => {
      return ajax({url})
  }
  
  // 使用
  ajax.get('http://www.baidu.com').then(data => {
      console.log(data)
  }, error => {
      console.log('状态码: ' + error)
  })
  ```

- Generator函数封装

  ```javascript
  const ajax = ({
      method = 'get',
      url = '/',
      async = true,
      data
  }) => {
      return new Promise((resolve, reject) => {
          let xhr = new XMLHttpRequest()
          xhr.onreadystatechange = () => {
              if (xhr.readyState === 4) {
                  if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                      let res = JSON.parse(xhr.responseText)
                      resolve(res)
                  } else {
                      reject('请求失败')
                  }
              }
          }
          xhr.open(method, url, async)
         if (method === 'get') {
             xhr.send(null)
         }
         if (method === 'post') {
             let type = typeof data
             let header
             if (type === 'string') {
                 header = 'application/x-www-form-urlencoded'
             } else {
                 header = 'application/json'
             }
             xhr.setRequestHeader('Content-type', header)
             xhr.send(data)
         }
      })
  }
  
  ajax.get = (url) => {
      return ajax({url})
  }
  function* use() {
      let data = yield ajax.get('http://www.baidu.com')
      console.log(data)
  }
  
  // 使用
  let gen = use()
  use.next().value.then(res => {
      gen.next(res)
  })
  
  ```

- Generator + co 封装

  ```javascript
  const ajax = ({
      method = 'get',
      url = '/',
      async = true,
      data
  }) => {
      return new Promise((resolve, reject) => {
          let xhr = new XMLHttpRequest()
          xhr.onreadystatechange = () => {
              if (xhr.readyState === 4) {
                  if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                      let res = JSON.parse(xhr.responseText)
                      resolve(res)
                  } else {
                      reject('请求失败')
                  }
              }
          }
          xhr.open(method, url, async)
         if (method === 'get') {
             xhr.send(null)
         }
         if (method === 'post') {
             let type = typeof data
             let header
             if (type === 'string') {
                 header = 'application/x-www-form-urlencoded'
             } else {
                 header = 'application/json'
             }
             xhr.setRequestHeader('Content-type', header)
             xhr.send(data)
         }
      })
  }
  
  ajax.get = (url) => {
      return ajax({url})
  }
  function* use() {
      let data = yield ajax.get('http://www.baidu.com')
      console.log(data)
  }
  
  // 使用
  co(use)
  ```

- Async封装

  ```javascript
  onst ajax = ({
      method = 'get',
      url = '/',
      async = true,
      data
  }) => {
      return new Promise((resolve, reject) => {
          let xhr = new XMLHttpRequest()
          xhr.onreadystatechange = () => {
              if (xhr.readyState === 4) {
                  if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                      let res = JSON.parse(xhr.responseText)
                      resolve(res)
                  } else {
                      reject('请求失败')
                  }
              }
          }
          xhr.open(method, url, async)
         if (method === 'get') {
             xhr.send(null)
         }
         if (method === 'post') {
             let type = typeof data
             let header
             if (type === 'string') {
                 header = 'application/x-www-form-urlencoded'
             } else {
                 header = 'application/json'
             }
             xhr.setRequestHeader('Content-type', header)
             xhr.send(data)
         }
      })
  }
  
  ajax.get = (url) => {
      return ajax({url})
  }
  
  async function use() {
      let data = await ajax.get('http://www.baidu.com')
      console.log(data)
  }
  
  use()
  ```

  



## 必考：这段代码里的 this 是什么？

## 必考：闭包/立即执行函数是什么？

### 闭包

有权访问另一个函数作用域中的变量的函数

闭包的创建：在一个函数内部创建另一个函数

## 必考：什么是 JSONP，什么是 CORS，什么是跨域？

### 什么是跨域？

​	跨域：协议， 域名， 端口号三者任意一个与当前页面url不同即为跨域

​	同源：协议，域名，端口号相同

​	浏览器同源策略：不同源的脚本在没有授权的情况下，不能读写对方的资源

### JSONP

因为<script> <iframe>的请求不受同源策略限制，通过将要请求的url写到script标签的src属性中实现跨域

```html
<script>
	function func() {
        // ...doSomeThing()
    }
</script>
<script src='http://localhost:4000/list?cb=func'></script>
```

特点：1.需要服务器端支持 2.只能发送get请求

### CORS

跨域资源共享

只需要后端在响应头设置`Access-Control-Allow-Origin: *`， * 为任意Origin，也可以指定Origin

使用CORS时默认不发送Cookie，想要发送Cookie需要:

1. 设置`Access-Control-Allow-Credentials: true`
2. 此时`Access-Control-Allow-Origin`不能设置为 * ，必须指定Origin

浏览器把请求分为简单请求与非简单请求

简单请求必须满足以下两大条件

1. 请求方法为 HEAD / GET / POST
2. HTTP头部不超过以下几种
   1. Accept
   2. Accept-Language
   3. Content-Language
   4. Last-Event-ID
   5. Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

不满足的就为非简单请求。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求。

这个请求的请求方法为`OPTIONS` ，预检请求的头部还会包括以下几个字段

```
Origin
```

`Access-Control-Request-Method` 用来表示非简单请求的请求方法

`Access-Control-Request-Headers` 用来表示非简单请求的额外头部，例如自定义头

## 常考：async/await 怎么用，如何捕获异常？

```js
async function f() {
    await new Promise()/...
}
```

### async/await基本使用：

`async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句

### 异常处理：

1. `async`函数内部抛出的错误，会导致返回的Promise对象变为`reject`状态，抛出的错误对象会被`catch`方法回调函数接收到

2. 任何一个`await`语句后面的Promise对象变为`reject`状态，那么整个`async`函数都会中断执行

   ```js
   async function f() {
     await Promise.reject('出错了');
     await Promise.resolve('hello world'); // 不会执行
   }
   ```

   ​	处理：

   - 将第一个`await`放在`try...catch`结构中

     ```js
     async function f() {
       try {
         await Promise.reject('出错了');
       } catch(e) {
       }
       return await Promise.resolve('hello world');
     }
     
     f()
     .then(v => console.log(v))
     // hello world
     ```

   - `await`后的Promise对象再跟一个`catch`方法

     ```javascript
     async function f() {
       await Promise.reject('出错了')
         .catch(e => console.log(e));
       return await Promise.resolve('hello world');
     }
     
     f()
     .then(v => console.log(v))
     // 出错了
     // hello world
     ```



## 常考：如何实现深拷贝？

深拷贝：拷贝属性的值而不是引用

```javascript
// 1. 利用JSON
JSON.parse(JSON.stringify(obj))
// 2.递归(简易版本)
function deepClone(source) {
    let target = null
    if (typeof source === 'object' && source) {
        target = Array.isArray(source)? [] : {}
        for (let [key, value] of Object.entries(source)) {
            target[key] = deepClone(value)
        }
    } else {
        target = source
    }
    return target
}
// 存在递归引用问题
let obj = {}
obj.a = obj
deepClone(obj)
// 会一直递归执行deepClone，造成函数栈溢出

// 3.复杂版本
// 使用WeakMap解决循环引用
function deepClone(source, hash = new WeakMap()) {
    let target = null
    if (hash.has(source)) {
        return hash.get(source)
    }
    if (typeof source === 'object' && source) {
        target = Array.isArray(source)? [] : {}
        hash.set(source, target)
        for (let [key, value] of Object.entries(source)) {
            target[key] = deepClone(value, hash)
        }
    } else {
        target = source
    }
    return target
}

// 4.同时拷贝原型上的属性
function completeDeepClone(source, hash = new WeakMap()) {
    let result = deepClone(source)
    Object.setPrototypeOf(result, Object.getPrototypeOf(source))
    return result
}
```



## 常考：如何用正则实现 trim()？

## 常考：不用 class 如何实现继承？用 class 又如何实现？

```javascript
function Person(name, age) {
    this.name = name
    this.age = age
}
// 构造继承
// 1.可以多继承（多个父类）
// 2.只能继承父类的实例属性和方法，不能继承原型属性和方法
function Student(name, age, school) {
    Person.call(this,name, age)
    this.school = school
}

// 原型链继承
// 1.不能多继承
// 2.所有新实例共享父类属性
function Student() {
    
}
Student.prototype = new Person('jt', 20)
Student.prototype.school = 'jxnu'
let stu = new Student()
    
// 组合继承
// 1.可以继承实例属性和方法，也可以原型属性和方法
// 2.两次调用了父类的构造函数，浪费了空间
function Student(name, age, school) {
    Person.call(this, name, age)
    this.school = school
}
Student.prototype = new Person()
Student.prototype.constructor = Student

// 寄生组合继承
function Student(name, age, school) {
    Person.call(this, name, age)
    this.school = school
}
Student.prototype = Object.create(Person.prototype)
Student.prototype.constructor = Student
Student.prototype.saySchool = function() {
	console.log(this.school)
}
let stu = new Student('jt', 20 ,'jxnu')
```



## 常考：如何实现数组去重？

```javascript
let arr1 = [1, 2, 2, 4, 9, 6, 7, 5, 2, 3, 5, 6, 5]

// 1.利用set
let arr2 = Array.from(new Set(arr))

// 2.简单去重
// 缺点：includes和indexOf都会遍历数组，时间复杂度高
function unique1(arr) {
    let newArr = []
    let item
    for (let i=0;i<arr.length;i++) {
        item =arr[i]
        if (!newArr.includes(item)) {
            newArr.push(item)
        }
    }
    return newArr
}

// 3.对象键值去重
// 把数组的值存放在对象的键值里，空间换时间，空间复杂度高，时间复杂度低
function unique2(arr) {
    let newArr = []
    let obj = {}
    let item
    let type
    for (let i=0;i<arr.length;i++) {
        item = arr[i]
        type = typeof item
        if (!obj[item]) {
            newArr.push(item)
            obj[item] = [type]
        } else if (!obj[item].includes(type)) {
            newArr.push(item)
            obj[item].push(type)
        }
    }
    return newArr
}

// 4.排序去重
// 给传入的数组排序，新数组只添加前一个不重复的数组
// 缺点：会打乱原数组的顺序
function unique3(arr) {
    let newArr = []
    let item
    arr.sort()
    newArr[0] = arr[0]
    for (let i=1;i<arr.length;i++) {
        item = arr[i]
        if (newArr[newArr.length - 1] !== item) {
            newArr.push(item)
        }
    }
    return newArr
}
```



1. 放弃：== 相关题目（反着答）
2. 送命题：手写一个 Promise

# DOM

1. 必考：事件委托
2. 曾考：用 mouse 事件写一个可拖曳的 div

# HTTP

## 缓存

浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档

**http缓存分为强缓存与协商缓存**

### 强缓存

强缓存是利用http头中的`Expires`和`Cache-Control`两个字段来控制的，用来表示资源的缓存时间

Expires：设置一个绝对时间，表示在这个时间后，缓存失效

Cache-Control：

- max-age：缓存最大时间，单位秒

### 协商缓存

协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。

Etag和If-None-Match

Last-Modified和If-Modify-Since

## 报文首部字段

### 请求首部字段

1. If-None-Match：比较实体标记 
2. If-Modified-Since：如果在改首部指定的时间后资源更新了，服务器就会处理请求

### 通用首部字段

1. Cache-Control：通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机 制

### 实体首部字段

1. Last-Modified：资源最后修改的时间
2. Expires：资源过期的日期时间

### 响应首部字段

## 状态码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作

### 状态码类别

|      | 类别                             | 原因                       |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接受的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

### 2XX成功

1. 200 OK 客户端发来的请求在服务器端正常处理
2. 204 No Content 服务器接收的请求已成功处理，但返回的响应报文中不含实体的主体部分
3. 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内

### 3XX重定向

1. 301 Moved Permanently 永久重定向
2. 302 Found 临时性重定向 该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问
3. 304 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访 问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系

### 4XX客户端错误

1. 401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息
2. 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了
3. 404 Not Found 该状态码表明服务器上无法找到请求的资源

### 5XX服务器错误



## HTTP缓存

## HTTP请求方法

| 方法   | 描述                                                         |
| :----- | ------------------------------------------------------------ |
| Get    | 通常用于请求资源                                             |
| Post   | 通常用于向服务端发送资源                                     |
| Delete | 通常用于删除资源                                             |
| Put    | 通常用于资源的更新，若资源不存在则新建一个                   |
| Option | 通常用于CORS的请求预检                                       |
| Head   | 只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源 |

### GET与POST区别（重点）

- Get请求的参数放在URL里，Post请求的参数放在实体里
- Get请求比起Post请求更加不安全，因为参数放在URL中，不能用来传递敏感信息
- Get请求的参数放在URL中，所以有长度限制；而Post请求没有限制
- Get发送一个tcp包，Post发送两个tcp包

1. ### Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session

# 框架 Vue

## 必考：watch 和 computed 和 methods 区别是什么？

## 必考：Vue 有哪些生命周期钩子函数？分别有什么用？

## 必考：Vue 如何实现组件间通信？

## 必考：Vue 数据响应式怎么做到的？

遍历data中的属性，给data中的属性使用`object.defiendProperty()`重新定义所有属性(get，set)

## 虚拟DOM 

### 双向数据绑定

当data中的数据发生改变，界面中用到对应数据的节点也会更新

页面通过用户交互也会发生数据的改变，视图对数据的更新同步到数据

## 必考：Vue.set 是做什么用的？

## Vuex 你怎么用的？

## VueRouter 你怎么用的？

## 路由守卫是什么？

# TypeScript

1. never 类型是什么？
2. TypeScript 比起 JavaScript 有什么优点？

# Webpack

## 必考：有哪些常见 loader 和 plugin，你用过哪些？

- file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件

- url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去

- source-map-loader：加载额外的 Source Map 文件，以方便断点调试

- image-loader：加载并且压缩图片文件

- babel-loader：把 ES6 转换成 ES5

- css-loader：加载 CSS，支持模块化、压缩、文件导入等特性

- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。

- eslint-loader：通过 ESLint 检查 JavaScript 代码

- define-plugin：定义环境变量

  commons-chunk-plugin：提取公共代码

  uglifyjs-webpack-plugin：通过`UglifyES`压缩`ES6`代码

## 英语题：loader 和 plugin 的区别是什么？

- **Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析*非JavaScript文件*的能力。
- **Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

## 必考：如何按需加载代码？

不过很多组件库已经提供了现成的解决方案，如Element出品的`babel-plugin-component`和AntDesign出品的`babel-plugin-import` 安装以上插件后，在`.babelrc`配置中或`babel-loader`的参数中进行设置，即可实现组件按需加载了。

```js
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
```

**单页应用的按需加载** 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。

通过`import(*)`语句来控制加载时机，webpack内置了对于`import(*)`的解析，会将`import(*)`中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到`import(*)`语句时，会去加载Chunk对应生成的文件。`import()`会返回一个Promise对象，所以为了让浏览器支持，需要事先注入`Promise polyfill`

## 必考：如何提高构建速度？

1. 多入口情况下，使用`CommonsChunkPlugin`来提取公共代码
2. 通过`externals`配置来提取常用库
3. 利用`DllPlugin`和`DllReferencePlugin`预编译资源模块 通过`DllPlugin`来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过`DllReferencePlugin`将预编译的模块加载进来。
4. 使用`Happypack` 实现多线程加速编译
5. 使用`webpack-uglify-parallel`来提升`uglifyPlugin`的压缩速度。 原理上`webpack-uglify-parallel`采用了多核并行压缩来提升压缩速度
6. 使用`Tree-shaking`和`Scope Hoisting`来剔除多余代码

## 转义出的文件过大怎么办？

上面五题请看这个不错的参考：https://zhuanlan.zhihu.com/p/44438844

# 安全

## 必考：什么是 XSS？如何预防？

Cross-Site Scripting(跨站脚本攻击)

当用户访问页面，攻击者插入自己的脚本，用户访问执行

## 必考：什么是 CSRF？如何预防？

# 性能优化

- 减少HTTP请求
  - 合并资源文件（CSS, JS, 雪碧图）
  - 压缩资源文件
  - 图片懒加载（借助IntersectionObserver）
  - 合理设置HTTP缓存， CDN缓存
- 首屏渲染优化
  - 代码分割，路由懒加载
  - 骨架屏
- 代码优化
  - 不用table （流式布局）
  - 不用with, eval
- CSS优化
  - CSS3（transform, opacity）硬件加速
  - 频繁操作DOM时，可以先用`display: none`使其脱离文档流再进行DOM操作
  - 对于复杂的动画效果，可以使用`position: absolute`使其脱离文档流
- JS优化
  - 函数防抖，函数节流

##### [#](https://messiahhh.github.io/blog/frontend/#图片懒加载)图片懒加载



# 设计模式

## mvc

用户操作会请求服务端路由，路由调用对应的控制器controller处理，controller继续向下调用获取数据，将结果返回给前端，页面重新渲染

m-model v-view c-control

## mvvm

m-model(json数据) v-view(html) vm-viewmodel(Vue的实例)