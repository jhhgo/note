# HTML

1. 必考：你是如何理解 HTML 语义化的？
2. meta viewport 是做什么用的，怎么写？
3. 你用过哪些 HTML 5 标签？
4. H5 是什么？

# CSS

## 基础

### 盒模型

- 必考：两种盒模型分别说一下

  标准盒模型：浏览器默认`box-sizing: content-box`

  当我们设置`width`的时候，设置的是盒模型的`content`，此时盒子的实际宽度等于`content(width)+padding+border+magin`

  怪异盒模型：通过设置`box-sizing: boder-box`，此时设置的`width`等于`content+padding+border`

### 布局

#### 必考：如何垂直居中？

1. absolute + margin

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       position: relative;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-top: -100px;
       margin-left: -100px;
   }
   ```

2. absolute + calc

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       position: relative;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       position: absolute;
       top: calc(50% - 100px);
       left: calc(50% - 100px);
   }
   ```

   **以上两种方法适用于元素已知高宽的情况，若高宽不确定，则不可使用**

3. absolute + transform

   ```css
   #outer {
       width: 500px;
       height: 500px;
       border: 1px solid black;
       position: relative;
   }
   #inner {
       width: 200px;
       height: 200px;
       background-color: red;
       position: absolute;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
   }
   ```

必考：flex 怎么用，常用属性有哪些？



1. 必考：BFC 是什么？
2. CSS 选择器优先级
3. 清除浮动说一下

# 原生 JS

1. ## 必考：ES 6 语法知道哪些，分别怎么用？

2. ## 必考 Promise、Promise.all、Promise.race 分别怎么用？

3. ## 必考：手写函数防抖和函数节流

   函数防抖：一定时间内，事件连续触发，只执行一次

   ```javascript
   function debounce(method, context) {
       clearTimeout(method.timer)
       method.timer = setTimeout(() => {
           method.call(context)
       }, 500)
   }
   ```

   函数节流：一定时间内，执行一次

   ```javascript
   function throttle(func, wait) {
       let timer
       return () => {
           if (timer) {
               return
           }
           timer = setTimeout(() => {
               fun()
               timer = null
           }, wait)
       }
   }
   ```

   

4. ## 必考：手写AJAX

   - 回调函数封装

     ```javascript
     const ajax = ({
         method = 'get',
         url = '/',
         async = true,
         data
     } = {}, callback) => {
         let xhr = new XMLHttpRequest()
         xhr.onreadystatechange = () => {
             if (xhr.readyState === 4 && xhr.status === 200) {
                 let res = JSON.parse(xhr.responseText)
                 callback(res)
             }
         }
         xhr.open(method, url, async)
         if (method === 'get') {
             xhr.send(null)
         }
         if (method === 'post') {
             let type = typeof data
             let header
             if (type === 'string') {
                 header = 'application/x-www-form-urlencoded'
             } else {
                 header = 'application/json'
                 data = JSON.stringify(data)
             }
         }
         xhr.setRequestHeader('Content-type', header)
         xhr.send(data)
     }
     ```

   - Promise封装

     ```javascript
     const ajax = ({
         method = 'get',
         url = '/',
         async = true,
         data
     }) => {
         return new Promise((resolve, reject) => {
             let xhr = new XMLHttpRequest()
             xhr.onreadystatechange = () => {
                 if (xhr.readyState === 4) {
                     if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                         let res = JSON.parse(xhr.responseText)
                         resolve(res)
                     } else {
                         reject(res.status)
                     }
                 }
             }
             xhr.open(method, url, async)
            if (method === 'get') {
                xhr.send(null)
            }
            if (method === 'post') {
                let type = typeof data
                let header
                if (type === 'string') {
                    header = 'application/x-www-form-urlencoded'
                } else {
                    header = 'application/json'
                }
                xhr.setRequestHeader('Content-type', header)
                xhr.send(data)
            }
         })
     }
     
     ajax.get = (url) => {
         return ajax({url})
     }
     
     // 使用
     ajax.get('http://www.baidu.com').then(data => {
         console.log(data)
     }, error => {
         console.log('状态码: ' + error)
     })
     ```

   - Generator函数封装

     ```javascript
     const ajax = ({
         method = 'get',
         url = '/',
         async = true,
         data
     }) => {
         return new Promise((resolve, reject) => {
             let xhr = new XMLHttpRequest()
             xhr.onreadystatechange = () => {
                 if (xhr.readyState === 4) {
                     if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                         let res = JSON.parse(xhr.responseText)
                         resolve(res)
                     } else {
                         reject('请求失败')
                     }
                 }
             }
             xhr.open(method, url, async)
            if (method === 'get') {
                xhr.send(null)
            }
            if (method === 'post') {
                let type = typeof data
                let header
                if (type === 'string') {
                    header = 'application/x-www-form-urlencoded'
                } else {
                    header = 'application/json'
                }
                xhr.setRequestHeader('Content-type', header)
                xhr.send(data)
            }
         })
     }
     
     ajax.get = (url) => {
         return ajax({url})
     }
     function* use() {
         let data = yield ajax.get('http://www.baidu.com')
         console.log(data)
     }
     
     // 使用
     let gen = use()
     use.next().value.then(res => {
         gen.next(res)
     })
     
     ```

   - Generator + co 封装

     ```javascript
     const ajax = ({
         method = 'get',
         url = '/',
         async = true,
         data
     }) => {
         return new Promise((resolve, reject) => {
             let xhr = new XMLHttpRequest()
             xhr.onreadystatechange = () => {
                 if (xhr.readyState === 4) {
                     if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                         let res = JSON.parse(xhr.responseText)
                         resolve(res)
                     } else {
                         reject('请求失败')
                     }
                 }
             }
             xhr.open(method, url, async)
            if (method === 'get') {
                xhr.send(null)
            }
            if (method === 'post') {
                let type = typeof data
                let header
                if (type === 'string') {
                    header = 'application/x-www-form-urlencoded'
                } else {
                    header = 'application/json'
                }
                xhr.setRequestHeader('Content-type', header)
                xhr.send(data)
            }
         })
     }
     
     ajax.get = (url) => {
         return ajax({url})
     }
     function* use() {
         let data = yield ajax.get('http://www.baidu.com')
         console.log(data)
     }
     
     // 使用
     co(use)
     ```

   - Async封装

     ```javascript
     onst ajax = ({
         method = 'get',
         url = '/',
         async = true,
         data
     }) => {
         return new Promise((resolve, reject) => {
             let xhr = new XMLHttpRequest()
             xhr.onreadystatechange = () => {
                 if (xhr.readyState === 4) {
                     if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                         let res = JSON.parse(xhr.responseText)
                         resolve(res)
                     } else {
                         reject('请求失败')
                     }
                 }
             }
             xhr.open(method, url, async)
            if (method === 'get') {
                xhr.send(null)
            }
            if (method === 'post') {
                let type = typeof data
                let header
                if (type === 'string') {
                    header = 'application/x-www-form-urlencoded'
                } else {
                    header = 'application/json'
                }
                xhr.setRequestHeader('Content-type', header)
                xhr.send(data)
            }
         })
     }
     
     ajax.get = (url) => {
         return ajax({url})
     }
     
     async function use() {
         let data = await ajax.get('http://www.baidu.com')
         console.log(data)
     }
     
     use()
     ```

     

   

5. ## 必考：这段代码里的 this 是什么？

6. ## 必考：闭包/立即执行函数是什么？

7. ## 必考：什么是 JSONP，什么是 CORS，什么是跨域？

   ### 什么是跨域？

   ​	跨域：协议， 域名， 端口号三者任意一个与当前页面url不同即为跨域

   ​	同源：协议，域名，端口号相同

   ​	浏览器同源策略：不同源的脚本在没有授权的情况下，不能读写对方的资源

   ### JSONP

   ### CORS

8. ## 常考：async/await 怎么用，如何捕获异常？

9. ## 常考：如何实现深拷贝？

   深拷贝：拷贝属性的值而不是引用

   ```javascript
   // 1. 利用JSON
   JSON.parse(JSON.stringify(obj))
   // 2.递归(简易版本)
   function deepClone(source) {
       let target = null
       if (typeof source === 'object' && source) {
           target = Array.isArray(source)? [] : {}
           for (let [key, value] of Object.entries(source)) {
               target[key] = deepClone(value)
           }
       } else {
           target = source
       }
       return target
   }
   // 存在递归引用问题
   let obj = {}
   obj.a = obj
   deepClone(obj)
   // 会一直递归执行deepClone，造成函数栈溢出
   
   // 3.复杂版本
   // 使用WeakMap解决循环引用
   function deepClone(source, hash = new WeakMap()) {
       let target = null
       if (hash.has(source)) {
           return hash.get(source)
       }
       if (typeof source === 'object' && source) {
           target = Array.isArray(source)? [] : {}
           hash.set(source, target)
           for (let [key, value] of Object.entries(source)) {
               target[key] = deepClone(value, hash)
           }
       } else {
           target = source
       }
       return target
   }
   
   // 4.同时拷贝原型上的属性
   function completeDeepClone(source, hash = new WeakMap()) {
       let result = deepClone(source)
       Object.setPrototypeOf(result, Object.getPrototypeOf(source))
       return result
   }
   ```

   

10. ## 常考：如何用正则实现 trim()？

11. ## 常考：不用 class 如何实现继承？用 class 又如何实现？

    ```javascript
    function Person(name, age) {
        this.name = name
        this.age = age
    }
    // 构造继承
    // 1.可以多继承（多个父类）
    // 2.只能继承父类的实例属性和方法，不能继承原型属性和方法
    function Student(name, age, school) {
        Person.call(this,name, age)
        this.school = school
    }
    
    // 原型链继承
    // 1.不能多继承
    // 2.所有新实例共享父类属性
    function Student() {
        
    }
    Student.prototype = new Person('jt', 20)
    Student.prototype.school = 'jxnu'
    let stu = new Student()
        
    // 组合继承
    // 1.可以继承实例属性和方法，也可以原型属性和方法
    // 2.两次调用了父类的构造函数，浪费了空间
    function Student(name, age, school) {
        Person.call(this, name, age)
        this.school = school
    }
    Student.prototype = new Person()
    Student.prototype.constructor = Student
    
    // 寄生组合继承
    function Student(name, age, school) {
        Person.call(this, name, age)
        this.school = school
    }
    Student.prototype = Object.create(Person.prototype)
    Student.prototype.constructor = Student
    Student.prototype.saySchool = function() {
    	console.log(this.school)
    }
    let stu = new Student('jt', 20 ,'jxnu')
    ```

    

12. ## 常考：如何实现数组去重？

    ```javascript
    let arr1 = [1, 2, 2, 4, 9, 6, 7, 5, 2, 3, 5, 6, 5]
    
    // 1.利用set
    let arr2 = Array.from(new Set(arr))
    
    // 2.简单去重
    // 缺点：includes和indexOf都会遍历数组，时间复杂度高
    function unique1(arr) {
        let newArr = []
        let item
        for (let i=0;i<arr.length;i++) {
            item =arr[i]
            if (!newArr.includes(item)) {
                newArr.push(item)
            }
        }
        return newArr
    }
    
    // 3.对象键值去重
    // 把数组的值存放在对象的键值里，空间换时间，空间复杂度高，时间复杂度低
    function unique2(arr) {
        let newArr = []
        let obj = {}
        let item
        let type
        for (let i=0;i<arr.length;i++) {
            item = arr[i]
            type = typeof item
            if (!obj[item]) {
                newArr.push(item)
                obj[item] = [type]
            } else if (!obj[item].includes(type)) {
                newArr.push(item)
                obj[item].push(type)
            }
        }
        return newArr
    }
    
    // 4.排序去重
    // 给传入的数组排序，新数组只添加前一个不重复的数组
    // 缺点：会打乱原数组的顺序
    function unique3(arr) {
        let newArr = []
        let item
        arr.sort()
        newArr[0] = arr[0]
        for (let i=1;i<arr.length;i++) {
            item = arr[i]
            if (newArr[newArr.length - 1] !== item) {
                newArr.push(item)
            }
        }
        return newArr
    }
    ```

    

13. 放弃：== 相关题目（反着答）

14. 送命题：手写一个 Promise

# DOM

1. 必考：事件委托
2. 曾考：用 mouse 事件写一个可拖曳的 div

# HTTP

1. 必考：HTTP 状态码知道哪些？分别什么意思？
2. 大公司必考：HTTP 缓存有哪几种？
3. 必考：GET 和 POST 的区别
4. Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session

# 框架 Vue

1. 必考：watch 和 computed 和 methods 区别是什么？
2. 必考：Vue 有哪些生命周期钩子函数？分别有什么用？
3. 必考：Vue 如何实现组件间通信？
4. 必考：Vue 数据响应式怎么做到的？
5. 必考：Vue.set 是做什么用的？
6. Vuex 你怎么用的？
7. VueRouter 你怎么用的？
8. 路由守卫是什么？

# TypeScript

1. never 类型是什么？
2. TypeScript 比起 JavaScript 有什么优点？

# Webpack

1. 必考：有哪些常见 loader 和 plugin，你用过哪些？
2. 英语题：loader 和 plugin 的区别是什么？
3. 必考：如何按需加载代码？
4. 必考：如何提高构建速度？
5. 转义出的文件过大怎么办？

上面五题请看这个不错的参考：https://zhuanlan.zhihu.com/p/44438844

# 安全

1. 必考：什么是 XSS？如何预防？
2. 必考：什么是 CSRF？如何预防？

# 开放题目

1. 必考：你遇到最难的问题是怎样的？
2. 你在团队的突出贡献是什么？
3. 最近在关注什么新技术
4. 有没有看什么源码，看了后有什么记忆深刻的地方，有什么收获

# 刁钻题目

1. 代码[1,2,3].map(parseInt)
2. 代码var a = {name: 'a'} a.x = a = {} 问 a.x 是多少？
3. `(a ==1 && a== 2 && a==3)` 可能为 true 吗？

# 超纲题

1. JS 垃圾回收机制
2. Eventloop 说一下

# 个性化题目

- PWA
- echarts.js / d3.js
- three.js
- flutter
- SSR