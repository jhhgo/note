# 小程序原理

## 小程序设计原理

基于安全和管控的目的，小程序采用双线程架构，分为逻辑层和渲染层。逻辑层执行 js,渲染层为 webview 负责渲染页面。由于开发者的逻辑代码放到单独的线程去执行，不在 webview 的线程里，没有 webview 的任何接口，自然无法直接操作 dom。

渲染层有多个 webview 线程，一个小程序页面对应一个 webview 线程，小程序的各个界面被管理在一个页面栈中。

既然渲染层和逻辑层分别在两个线程中，那么是如何通信的？

## virtualdom 和双线程通信

**virtual dom**

在渲染层中，WXML 会被转化成用于描述虚拟 DOM 树的 js 对象。当数据发生变化，会生成一颗新的虚拟 DOM 树，通过`diff`生成一组差异记录，并应用到真实 DOM 上。

**双线程通信方式**

双线程通信时会将要传输的数据转换为字符串形式。逻辑层调用`setData`将数据同步到渲染层。

setData 调用的过程：

-   当开发者调用`setData`时，底层会使用`JSON.stringify`处理一遍数据，一些不可序列化的数据会被移除

-   逻辑层将数据发送给渲染层，同时会同步更新页面中的 data 数据，在调用`setData`后，可以通过`this.data`获取变更后的最新数据

-   由于数据的传输需要通过`native`进行中转，所以`setData`将数据从逻辑层发送到渲染层是异步的。如果我们需要知道界面渲染完毕，可以在调用`setData`时传入`callback`

-   `setData`仅支持序列化的数据，单次设置的数据不能超过`1024KB`

## 渲染层渲染流程

**页面渲染流程**

-   新建页面在渲染层进行，渲染层 WXML 生成一个`virtual dom`的 js 对象，拼接`shadow tree`，注入初始数据进行渲染。

-   逻辑层调用`setData`后，通过 native 将数据传递到渲染层

-   渲染层对需要更新的数据进行`diff`，得到差异，然后把差异应用到真实 dom 中，从而更新页面

**自定义组件渲染流程**

对于开发者来说，逻辑层需要知道组件创建、销毁等生命周期的状态，假如自定义组件的渲染也在渲染层完成。那么每个自定义组件的所有状态和生命周期的变更都需要通过系统层转发到逻辑层，通信就会过于频繁和密集。

所以，我们在两个线程都需要保存一份节点信息。

更新流程如下 👇

-   逻辑层新建组件，并通知渲染层。在逻辑层，wxml 和 js 需要生成一个 js 对象，然后 js 的节点部分生成`virtual dom`信息，然后通过底层通信通知到渲染层。渲染层拿到`virtual dom`信息后，创建`shadow dom`，拼接`shadow tree`，注入初始数据渲染。

-   逻辑层调用`setData`，更新数据到渲染层。逻辑层调用`setData`后，在逻辑层进行`diff`，然后将 diff 结果传到渲染层。

-   渲染层组件更新。渲染层拿到 diff 信息，更新`virtual dom`节点信息，同时渲染页面。

## 小程序的基础库

小程序的基础库是使用 javascript 编写的，它可以它同时被注入渲染层和逻辑层运行。
小程序的基础库主要包括以下 4 个部分。

-   提供 virtual dom 渲染机制的相关基础代码，解决双线程你的渲染问题

-   提供封装后的内置组件

-   提供逻辑层的 api

-   提供其他补充能力的基础代码

### 小程序的启动

**小程序的启动流程**

-   页面预渲染。准备页面，逻辑层和渲染层分别进行初始化以及公共库的注入，逻辑层和渲染层是并行进行的，并不会相互依赖和阻塞。

-   小程序启动。当用户打开小程序后，小程序开始下载业务代码，同时会在本地创建基础 UI。准备完成后，开始注入业务代码，启动运行业务逻辑。

-   在小程序启动时，微信会为小程序展示一个固定的启动界面。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。

**热启动和冷启动**

小程序的启动分为热启动和冷启动。

热启动：用户通过右上角的胶囊关闭小程序，此时小程序只是切换到了后台，并没有真正地关闭。当用户再次点进小程序，就触发了热启动，恢复到上次的状态。

冷启动：当小程序切换到后台时间过久（超过 5 分钟）、主动删除小程序、用户杀掉微信进程、小程序占用资源过高被微信回收资源等情况。当用户再次进入小程序就会触发冷启动。
