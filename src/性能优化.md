## 性能指标

**FCP(First Contentful Paint)**

**LCP(Largest Contentful Paint)**

## 缓存

### HTP 缓存

强缓存、协商缓存

### webpack 缓存

## 发送请求

### DNS 预解析

```html
<link rel="dns-prefetch" href="//baidu.com" />
```

DNS Prefetch 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 baidu.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 baidu.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：

### 预先建立连接

### 使用 CDN

对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。

## 页面解析处理

### 注意资源在页面文档中的位置

总结：js 会阻塞 dom 的构建，cssom 的构建会阻塞 js

所以： CSS 样式表放在`<head>`中，js 脚本放在`<body>`的最后。

### defer 和 async

可以使用`defer` 或 `async` 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：

![defer和async](C:\Users\姜嘿嘿\Desktop\imgs\async和defer.png)

-   `defer`: 下载时不会阻塞 dom，下载好后，在解析 dom 之后再按照顺序执行
-   `async`: 下载不会阻塞 dom，但下载好后，马上执行，阻塞 dom

## 页面静态资源

**减少不必要的请求**

-   对于不需要使用的内容，其实不需要请求，否则相当于做了无用功
-   对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载
-   对于可以合并的资源，进行资源合并也是一种方法

**减少包体大小**

-   使用适合当前资源的压缩技术
-   避免再响应包体里“塞入”一些不需要的内容

**利用缓存**

### js

从 webpack 的角度回答：

**减少不必要请求**

-   按需加载
-   code split

**减少包体大小**

-   压缩代码
-   tree shraking
-   提取公共代码 optimization

可以通过 `webpack-bundle-analyzer` 这个工具来查看打包代码里面各个模块的占用大小。

### css

**简化选择器**

每一个元素查找匹配的规则会造成性能问题，同时，复杂的层叠规则也会带来很高的复杂度。正是由于这些问题，我们应该尽量避免不必要的选择器复杂度。

使用 less 和 sass 等，避免过多的嵌套。

**从重绘重排的角度**

### 图片

**优化请求数**

-   雪碧图

将多个小图片，合成到一个大图片少，减少请求数量

然后通过`background-position`设置需要展示的小图片在大图片中的位置

-   懒加载

### 字体

### 视频
