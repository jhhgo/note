# 动态规划

## 概念

维基百科：

> 动态规划在寻找有很多重叠子问题的情况的最佳解时有效。它将问题重新组合成子问题，为了避免多次解决这些子问题，它们的结果都逐渐被计算并被储存，从简单的问题直到整个问题都被解决。因此，动态规划储存递归时的结果，因而不会在解决同样的问题时花费时间。动态规划只能应用于有最佳子结构的问题。最佳子结构的意思是局部最佳解能决定全域最佳解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

最优子结构（子问题不互相依赖，子问题可独立被解决，由子问题推到出原问题答案） + 重复子问题 + 状态转移方程（数学归纳）

## 解题

- 状态定义
  1. 使用一个 dp 数组保存前置结果
  2. 要明确 dp[i]的含义。例如硬币问题，dp[i]代表最少用多少个硬币拼出 i 元
- 状态转移方程
  1. 明确数组项之间的关系，一般是 dp[i]与 dp[i-1],dp[i-2]之间的关系
- 初始化，边界条件
  1. 有时 dp[0]的值不能通过转移方程求出，需要手动输入

## 如何判断动态规划题

1. 计数

2. 求最大值最小值

3. 求存在性

## 题目合集

### 零钱兑换

[leetcode](https://leetcode-cn.com/problems/coin-change/)

> 问题描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。

**示例：**

```js
输入: (coins = [1, 2, 5]), (amount = 11)
输出: 3
解释: 11 = 5 + 5 + 1

输入: (coins = [2]), (amount = 3)
输出: -1
```

> 思路：

- 状态定义：

  1. dp[i]表示拼出 i 元所需的最少硬币数

- 状态转移方程：

  1. 假设硬币数组为[1, 2, 5]
  2. dp[i] = min{dp[i-1]+1,dp[i-2]+1, dp[i-5]+1}

- 初始化与边界条件：
  1. dp[0] = 0，拼出 0 元所需的最少硬币为 0
  2. 边界条件，当 i<硬币面值或(i-coin)元无法被拼出时

```js
var coinChange = function (coins, amount) {
  let dp = new Array(amount + 1)
  // 初始化
  dp[0] = 0
  for (let i = 1; i < dp.length; i++) {
    // 初始化，d[i]=Number.MAX_VALUE代表，i元无法被拼出
    dp[i] = Number.MAX_VALUE
    for (let j = 0; j < coins.length; j++) {
      if (i >= coins[j] && dp[i - coins[j]] !== Number.MAX_VALUE) {
        dp[i] = Math.min(dp[i - coins[j]] + 1, dp[i])
      }
    }
  }
  if (dp[amount] === Number.MAX_VALUE) return -1
  return dp[amount]
}
```

### 序列问题

#### 300. 最长递增子序列

1. 最长递增子序列可以由`子数组`最长递增子序列推断得出 （最优子结构）
2. dp数组定义。dp[i]表示以nums[i]结尾的数组的最长递增子序列的长度
3. 状态转移方程：dp[i] = max(dp[j] + 1) `j<i` 。条件nums[i] > nums[j]

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    // dpi定义 以numsi结尾的数组的最长递增序列的长度
    // dp[0] = 1
    // 状态转移方程:dp[i] = max(dp[i-1] + 1)。条件：nums[i] > nums[i-1]
    const dp = new Array(nums.length)
    dp[0] = 1
    for (let i = 1;i<dp.length;i++) {
        dp[i] = 1
        for (let j = 0;j<i;j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return Math.max(...dp)
};
```

#### 354. 俄罗斯套娃信封问题

当前信封w h都小于另一个信封时，当前信封可以放入另一个信封。

题目类似于求最长递增子序列的长度，但是需要同时满足宽度、高度的递增。

![hhh](../img/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83.png)

如图，可以对数组元素宽度进行升序排序，保证了宽度的递增。注意：当宽度相同时，按高度降序排序（因为宽度相同不可放入另一个信封）。接下来求高度的最长递增子序列的长度即可

#### 72. 编辑距离

```js
var minDistance = function(word1, word2) {
    // dp定义：dp是二维数组
    // dp[i][j]代表word1(0~i)的序列转换成word2(0~j)所需的最少编辑距离
    // 状态转移dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1])
    // dp[i][j-1] 代表插入，dp[i-1][j]代表删除，dp[i-1][j-1]代表替换
    let dp = new Array(word1.length + 1)
    for (let i = 0;i<dp.length;i++) {
        dp[i] = new Array(word2.length+1)
        dp[i][0] = i
        for (let j =0;j<dp[i].length;j++) {
            dp[0][j] = j
        }
    }
    for (let i=1;i<word1.length+1;i++) {
        for (let j=1;j<word2.length+1;j++) {
            if (word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)
            }
        }
    }

    return dp[word1.length][word2.length]
};
```

#### 53. 最大子数组和

dpi定义：nums[0,...i]的最大子数组和
dp[0] = nums[0]
状态转移：dp[i] = max(nums[i], dp[i-1] + nums[i])
dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组.

```js
var maxSubArray = function(nums) {
    // dpi：以numsi结尾的的子数组的最大和
    // dp[0] = nums[i]
    // dp[i] = max(nums[i], dp[i-1] + nums[i])

    const dp = new Array(nums.length)
    dp[0] = nums[0]
    for (let i=1;i<dp.length;i++) {
        dp[i] = Math.max(nums[i], dp[i-1] + nums[i])
    }

    return Math.max(...dp)
};
```

#### 1143. 最长公共子序列

```js
var longestCommonSubsequence = function(text1, text2) {
    // dp[i][j]定义：text1[0,...i] 和text2[0,...j]的最长公共子序列的长度
    // 初始化：空字符串没有公共子序列 dp[0][j] = 0 dp[i][0] = 0
    // 画出dp，手动填写。以abcde和ace为例
    //    '' a c e
    // '' 0  0 0 0
    // a  0  1 1 1
    // b  0  1 1 1
    // c  0  1 2 1
    // d  0  1 2 1
    // e  0  1 1 3
    // 状态转移：当text1[i] === text2[i] 有：dp[i][j] = dp[i-1][j-1] + 1
    // 不等于时候有两种情况： 以ab 和ace为例子。e !== b 有 dp[i][j] = ab与ac的最长公共子序列的长度或者 a和ace最长公共子序列的长度
    // 所以 当text1[i] !== text2[i] 有：dp[i][j] = max(dp[i-1][j], dp[i])
    const n1 = text1.length + 1
    const n2 = text2.length + 1
    const dp = new Array(n1)
    for (let i=0;i<dp.length;i++) {
        dp[i] = new Array(n2).fill(0)
    }

    for (let i=1;i<n1;i++) {
        for (let j=1;j<n2;j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
            }
        }
    }

    return dp[n1-1][n2-1]
};
```

#### 583. 两个字符串的删除操作

两个字符串删除后的结果，是它们的最长公共子序列。
所以问题可以转换成求最长公共子序列的长度，通过长度计算出删除的次数

```js
var minDistance = function (word1, word2) {
    let len1 = word1.length, len2 = word2.length;
    let dp = Array.from(new Array(len1 + 1), () => new Array(len2 + 1).fill(0));

    for (let i=1;i<len1 + 1;i++) {
        for (let j=1;j<len2+1;j++) {
            if (word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return len1 - dp[len1][len2] + len2 - dp[len1][len2]
};
```

#### 712. 两个字符串的最小ASCII删除和

dp[i][j]定义：使s1[0, ...i]和s2[0, ...j]相等所需删除字符的 ASCII 值的最小和 

初始化 dp[0][j] = dp[0][j-1] + s2[j-1]
      dp[i][0] = dp[i-1][0] + s1[i-1] 

dp表 以字符串delete 和 leet为例 👇

```js
   ''   l    e    e    t
'' 0    108  209  310  426
d  100  208  309  410  526
e  201  309  208  309  425
l  ...  ...  ...  ...  ...
```

状态转移：if s1[i] === s2[j] dp[i][j] = dp[i-1][j-1]
else dp[i][j] = min(dp[i-1][j] + s1[i], dp[i][j-1] + s2[j])
解释：以字符串del、le为例。求del 和le相等所需删除字符的 ASCII 值的最小和。l !== e有两种情况
1. del和l相等所需删除的最小和，然后删除e
2. de和le相等所需删除的最小和，然后删除l
两者取最小即可

```js
var minimumDeleteSum = function(s1, s2) {
    // dp[i][j]定义：使s1[0,...i]和s2[0,...j]相等所需删除字符的 ASCII 值的最小和
    let len1 = s1.length
    let len2 = s2.length
    let dp = Array.from({length: len1+1}, () => new Array(len2+1).fill(0))
    dp[0][0] = 0
    for (let i=1;i<len2+1;i++) {
        dp[0][i] = dp[0][i-1] + s2[i-1].charCodeAt()
    }
    for (let j=1;j<len1+1;j++) {
        dp[j][0] = dp[j-1][0] + s1[j-1].charCodeAt()
    }
    for (let i=1;i<len1+1;i++) {
        for (let j=1;j<len2+1;j++) {
            if (s1[i-1] === s2[j-1]){
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = Math.min(dp[i-1][j] + s1[i-1].charCodeAt(), dp[i][j-1] + s2[j-1].charCodeAt())
            }
        }
    }
    return dp[len1][len2]
};
```
