# 浏览器工作原理

## 浏览器架构

### 进程与线程

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

而线程是不能单独存在的，它由进程来启动和管理

一个便于理解的解释👇
[进程与线程](https://www.zhihu.com/question/25532384)

### chrome目前的多进程架构

![chrome多进程架构](C:\Users\姜嘿嘿\Desktop\imgs\chrome多进程架构.png)

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

多进程架构提升了浏览器的稳定性、安全性，同样也带来了一些问题：

- 更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源
- 更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

## 浏览器渲染机制

1. 浏览器先对得到的HTML进行解码，之后进行网络资源的预处理，将以后要发送的请求提前加进请求队列中
2. 浏览器将html解析成多个标记（标记化Tokenization），之后根据标记构造DOM树。在html中会引入图片 css等资源，这些资源不会阻塞html的解析。**但遇到script标签，会停止html解析过程，转而解析并执行js**
3. CSS同理，先进行标记化，再进行css样式树的构建
4. 浏览器将DOM树和CSS样式树结合，生成渲染树
5. 布局（layout）：浏览器根据渲染树，计算每个渲染对象在屏幕上的位置和尺寸
6. 绘制（paint）：将计算好的像素点绘制到屏幕
7. 渲染层合成：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上

## 1.1 回流/重排（reflow）
**当渲染对象的位置，尺寸，或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程**

导致回流的操作：
1. 页面首次渲染
2. 元素位置或尺寸发生改变
3. 添加或删除可见的DOM元素
4. 浏览器窗口大小发生变化
5. 查询某些属性或调用某些方法
	`clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
	`offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
	`scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
	`scrollIntoView()`、`scrollIntoViewIfNeeded()`
	`getComputedStyle()`
	`getBoundingClientRect()`
	`scrollTo()`
	
## 1.2重绘
样式改变但不改变渲染对象在文档流中的位置时（如：background-color）浏览器重新绘制
回流一定重绘，重绘不一定回流。回流比重绘的代价高

## 浏览器事件模型

### 1.事件传播

```html
<body>
	<div class="outer">
		<div class="inner"></div>
	</div>
</body>
```

当我们点击inner元素
步骤1：点击事件传播途径：body -> outer -> inner。从外到里，称为事件捕获
步骤2：点击事件传播途径：inner -> outer -> body。从里到外，称为事件冒泡

### 2.DOM事件流

DOM2级事件流包括3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
**ie8及以下不支持**

### 3.取消事件捕获/冒泡

利用`event.stopPropagation()`方法

```js
let outer = document.querySelector('.outer')
let inner = document.querySelector('.inner')

outer.addEventListener('click', (e) => {
	console.log('outer')
	e.stopPropagation()
})

inner.addEventListener('click', (e) => {
	console.log('inner')
	e.stopPropagation()
})
```

### 4.事件委托/代理

将事件绑定到父类元素上，而不是所有子类元素。
利用`event.target`实现

```js
let ul = document.querySelectorAll('ul')[0]
ul.addEventListener('click', (e) => {
	console.log(e.target.innerHTML)
})
```

事件代理的好处：
1. 只用给一个元素监听事件，减少内存的使用
2. 当动态增加或删除节点时，不用手动重新监听事件

## 浏览器客户端存储

### 1.LocalStorage

localStorage存储在客户端，并且没有过期时间设置，除非主动删除否则不会过期

### 2.SessionStorage

sessionStorage存储在客户端，会话结束（关闭页面）时，数据清除

### 3.Cookie

浏览器发送HTTP请求时，先检查是否有相应的Cookie，如果有则将Cookie放在请求头中的Cookie字段中发送

#### 3.1 相关属性

1. `expires`：设置Cookie过期时间
2. `secure`：设为true时只能使用https
3. `httpOnly`：
4. domain和path：限制cookie能被哪些url访问
5. SameSite

#### 3.2 Cookie封装

```js
const cookieUtil = {
	setItem(key, value, days) {
		let date = new Date()
		date.setDate(date.getDate() + days)
		document.cookie = `${key}=${value};expires=${date}`
	},
	getItem(key) {
		let cookies = document.cookie.split(';')
		let ret
		cookies.forEach(item => {
			let tempArr = item.split('=')
			if (tempArr[0] === key) {
				ret = tempArr[1]
			}
		})
		return ret
	},
	removeItem(key) {
		this.setItem(key, null, -1)
	}
}
```

#### 3.3 Cookie和Storage的对比

1. Cookie存放数据小，4kb左右。而Storage可以存放5MB左右
2. Cookie可以设置过期时间，sessionStorage在关闭页面自动过期，localStorage必须手动清除
3. Cookie参与服务器通信，storage一般不用
4. 每次请求同意域名都会在请求头带上所有cookie，过多的cookie造成性能浪费

### 4.Session

通常使用Cookie时，会话数据都存在Cookie中。使用Session时，Cookie中只存放一个Session_id，会话数据放在服务端的内存或数据库中

![session](https://pic3.zhimg.com/v2-b4c952a1f71313670b94898b2bea4f6a_r.jpg)

### 5.JWT














