# 浏览器渲染机制

1. 浏览器先对得到的HTML进行解码，之后进行网络资源的预处理，将以后要发送的请求提前加进请求队列中
2. 浏览器将html解析成多个标记（标记化Tokenization），之后根据标记构造DOM树。在html中会引入图片 css等资源，这些资源不会阻塞html的解析。**但遇到script标签，会停止html解析过程，转而解析并执行js**
3. CSS同理，先进行标记化，再进行css样式树的构建
4. 浏览器将DOM树和CSS样式树结合，生成渲染树
5. 布局（layout）：浏览器根据渲染树，计算每个渲染对象在屏幕上的位置和尺寸
6. 绘制（paint）：将计算好的像素点绘制到屏幕
7. 渲染层合成：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上

## 1.1 回流/重排（reflow）
**当渲染对象的位置，尺寸，或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程**

导致回流的操作：
1. 页面首次渲染
2. 元素位置或尺寸发生改变
3. 添加或删除可见的DOM元素
4. 浏览器窗口大小发生变化
5. 查询某些属性或调用某些方法
	`clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
	`offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
	`scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
	`scrollIntoView()`、`scrollIntoViewIfNeeded()`
	`getComputedStyle()`
	`getBoundingClientRect()`
	`scrollTo()`
	
## 1.2重绘
样式改变但不改变渲染对象在文档流中的位置时（如：background-color）浏览器重新绘制
回流一定重绘，重绘不一定回流。回流比重绘的代价高

# 浏览器事件模型

## 1.事件传播

```html
<body>
	<div class="outer">
		<div class="inner"></div>
	</div>
</body>
```

当我们点击inner元素
步骤1：点击事件传播途径：body -> outer -> inner。从外到里，称为事件捕获
步骤2：点击事件传播途径：inner -> outer -> body。从里到外，称为事件冒泡

## 2.DOM事件流

DOM2级事件流包括3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
**ie8及以下不支持**

## 3.取消事件捕获/冒泡

利用`event.stopPropagation()`方法

```js
let outer = document.querySelector('.outer')
let inner = document.querySelector('.inner')

outer.addEventListener('click', (e) => {
	console.log('outer')
	e.stopPropagation()
})

inner.addEventListener('click', (e) => {
	console.log('inner')
	e.stopPropagation()
})
```

## 4.事件委托/代理

将事件绑定到父类元素上，而不是所有子类元素。
利用`event.target`实现

```js
let ul = document.querySelectorAll('ul')[0]
ul.addEventListener('click', (e) => {
	console.log(e.target.innerHTML)
})
```

事件代理的好处：
1. 只用给一个元素监听事件，减少内存的使用
2. 当动态增加或删除节点时，不用手动重新监听事件

# 浏览器客户端存储

## 1.LocalStorage

localStorage存储在客户端，并且没有过期时间设置，除非主动删除否则不会过期

## 2.SessionStorage

sessionStorage存储在客户端，会话结束（关闭页面）时，数据清除

## 3.Cookie

浏览器发送HTTP请求时，先检查是否有相应的Cookie，如果有则将Cookie放在请求头中的Cookie字段中发送

### 3.1 相关属性

1. `expires`：设置Cookie过期时间
2. `secure`：设为true时只能使用https
3. `httpOnly`：
4. domain和path：限制cookie能被哪些url访问
5. SameSite

### 3.2 Cookie封装

```js
const cookieUtil = {
	setItem(key, value, days) {
		let date = new Date()
		date.setDate(date.getDate() + days)
		document.cookie = `${key}=${value};expires=${date}`
	},
	getItem(key) {
		let cookies = document.cookie.split(';')
		let ret
		cookies.forEach(item => {
			let tempArr = item.split('=')
			if (tempArr[0] === key) {
				ret = tempArr[1]
			}
		})
		return ret
	},
	removeItem(key) {
		this.setItem(key, null, -1)
	}
}
```

### 3.3 Cookie和Storage的对比

1. Cookie存放数据小，4kb左右。而Storage可以存放5MB左右
2. Cookie可以设置过期时间，sessionStorage在关闭页面自动过期，localStorage必须手动清除
3. Cookie参与服务器通信，storage一般不用
4. 每次请求同意域名都会在请求头带上所有cookie，过多的cookie造成性能浪费

## 4.Session

通常使用Cookie时，会话数据都存在Cookie中。使用Session时，Cookie中只存放一个Session_id，会话数据放在服务端的内存或数据库中

![session](https://pic3.zhimg.com/v2-b4c952a1f71313670b94898b2bea4f6a_r.jpg)

## 5.JWT














