# 浏览器相关问题

## 浏览器架构

### 进程与线程

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

而线程是不能单独存在的，它由进程来启动和管理

一个便于理解的解释👇
[进程与线程](https://www.zhihu.com/question/25532384)

### chrome目前的多进程架构

![chrome多进程架构](C:\Users\姜嘿嘿\Desktop\imgs\chrome多进程架构.png)

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

多进程架构提升了浏览器的稳定性、安全性，同样也带来了一些问题：

- 更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源
- 更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

## 浏览器渲染机制

1. 浏览器先对得到的HTML进行解码，之后进行网络资源的预处理，将以后要发送的请求提前加进请求队列中
2. 浏览器将html解析成多个标记（标记化Tokenization），之后根据标记构造DOM树。在html中会引入图片 css等资源，这些资源不会阻塞html的解析。**但遇到script标签，会停止html解析过程，转而解析并执行js**
3. CSS同理，先进行标记化，再进行css样式树的构建
4. 浏览器将DOM树和CSS样式树结合，生成渲染树
5. 布局（layout）：浏览器根据渲染树，计算每个渲染对象在屏幕上的位置和尺寸
6. 绘制（paint）：将计算好的像素点绘制到屏幕
7. 渲染层合成：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上

## 1.1 回流/重排（reflow）
**当渲染对象的位置，尺寸，或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程**

导致回流的操作：
1. 页面首次渲染
2. 元素位置或尺寸发生改变
3. 添加或删除可见的DOM元素
4. 浏览器窗口大小发生变化
5. 查询某些属性或调用某些方法
	`clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
	`offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
	`scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
	`scrollIntoView()`、`scrollIntoViewIfNeeded()`
	`getComputedStyle()`
	`getBoundingClientRect()`
	`scrollTo()`
	
## 1.2重绘
样式改变但不改变渲染对象在文档流中的位置时（如：background-color）浏览器重新绘制
回流一定重绘，重绘不一定回流。回流比重绘的代价高

## 浏览器事件模型

### 1.事件传播

```html
<body>
	<div class="outer">
		<div class="inner"></div>
	</div>
</body>
```

当我们点击inner元素
步骤1：点击事件传播途径：body -> outer -> inner。从外到里，称为事件捕获
步骤2：点击事件传播途径：inner -> outer -> body。从里到外，称为事件冒泡

### 2.DOM事件流

DOM2级事件流包括3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
**ie8及以下不支持**

### 3.取消事件捕获/冒泡

利用`event.stopPropagation()`方法

```js
let outer = document.querySelector('.outer')
let inner = document.querySelector('.inner')

outer.addEventListener('click', (e) => {
	console.log('outer')
	e.stopPropagation()
})

inner.addEventListener('click', (e) => {
	console.log('inner')
	e.stopPropagation()
})
```

### 4.事件委托/代理

将事件绑定到父类元素上，而不是所有子类元素。
利用`event.target`实现

```js
let ul = document.querySelectorAll('ul')[0]
ul.addEventListener('click', (e) => {
	console.log(e.target.innerHTML)
})
```

事件代理的好处：
1. 只用给一个元素监听事件，减少内存的使用
2. 当动态增加或删除节点时，不用手动重新监听事件

## 浏览器客户端存储

### 1.LocalStorage

localStorage存储在客户端，并且没有过期时间设置，除非主动删除否则不会过期

### 2.SessionStorage

sessionStorage存储在客户端，会话结束（关闭页面）时，数据清除

### 3.Cookie

浏览器发送HTTP请求时，先检查是否有相应的Cookie，如果有则将Cookie放在请求头中的Cookie字段中发送

#### 3.1 相关属性

1. `expires`：设置Cookie过期时间
2. `secure`：设为true时只能使用https
3. `httpOnly`：
4. domain和path：限制cookie能被哪些url访问
5. SameSite

#### 3.2 Cookie封装

```js
const cookieUtil = {
	setItem(key, value, days) {
		let date = new Date()
		date.setDate(date.getDate() + days)
		document.cookie = `${key}=${value};expires=${date}`
	},
	getItem(key) {
		let cookies = document.cookie.split(';')
		let ret
		cookies.forEach(item => {
			let tempArr = item.split('=')
			if (tempArr[0] === key) {
				ret = tempArr[1]
			}
		})
		return ret
	},
	removeItem(key) {
		this.setItem(key, null, -1)
	}
}
```

#### 3.3 Cookie和Storage的对比

1. Cookie存放数据小，4kb左右。而Storage可以存放5MB左右
2. Cookie可以设置过期时间，sessionStorage在关闭页面自动过期，localStorage必须手动清除
3. Cookie参与服务器通信，storage一般不用
4. 每次请求同意域名都会在请求头带上所有cookie，过多的cookie造成性能浪费

### 4.Session

通常使用Cookie时，会话数据都存在Cookie中。使用Session时，Cookie中只存放一个Session_id，会话数据放在服务端的内存或数据库中

![session](https://pic3.zhimg.com/v2-b4c952a1f71313670b94898b2bea4f6a_r.jpg)

### 5.JWT

## history路由和hash路由

**为什么使用前端路由？**

单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；前端路由则提供了随着浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。

### hash路由

> 使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。

hash特性👇

1. url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。

2. hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换。

3. 我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。

**触发hashchange事件的几种情况**

1. 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件。

2. 当浏览器地址栏中URL包含哈希如 http://www.baidu.com/#home，这时按下输入，浏览器发送http://www.baidu.com/请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件。

3. `<a>`标签

```html
<a href="#test">to somewhere</a>
```

4. 直接赋值给`location.hash`

```js
location.hash = '#jhh'
```

### history路由

**概述**

- window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。
- History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。
- 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。
- 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。

**History对象的属性**

- `history.length`: 当前窗口访问过的网址数量

- `history.state`: History 堆栈最上层的状态值

**History对象的方法**

- `History.back()`：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。

- `History.forward()`：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果
。
- `History.go()`：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。

```js
history.back();
history.forward();
history.go(1);//相当于history.forward()
history.go(-1);//相当于history.back()
history.go(0); // 刷新当前页面
```

**History.pushState**

用于在历史中添加一条记录。但是不会触发页面刷新，只是导致`History`对象发生变化，地址栏有变化

```js
history.pushState(state, title, url)
```

- state : 一个于指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null。

- title : 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。

- url : 新的网址，必须与前页面处在同一个域。浏览器的地址栏将显示这个网址。


**History.replaceState**

替换当前的历史记录，不刷新页面

```js
history.replaceState(state, title, url)
```

- 用法和`pushState`一致
- `replaceState`是替换当前历史记录而不是添加

**popstate 事件**

每当`History`发生变化时，都会触发`popstate`事件

- 仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件。

- 只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、 History.go()方法时才会触发。

- 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。

- 页面第一次加载的时候，浏览器不会触发popstate事件。












