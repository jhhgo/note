# 浏览器相关问题

## 浏览器架构

### 进程与线程

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

而线程是不能单独存在的，它由进程来启动和管理

一个便于理解的解释👇
[进程与线程](https://www.zhihu.com/question/25532384)

### chrome目前的多进程架构

![chrome多进程架构](C:\Users\姜嘿嘿\Desktop\imgs\chrome多进程架构.png)

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

多进程架构提升了浏览器的稳定性、安全性，同样也带来了一些问题：

- 更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源
- 更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

## 浏览器渲染机制

浏览器渲染机制总结为以下过程：

1. 构建DOM树
2. 样式计算
3. 布局阶段
4. 分层
5. 绘制
6. 分块
7. 光栅化
8. 合成

### 构建DOM树

这个过程将拿到的html文件转化为浏览器`DOM`树结构。

一段html代码👇

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

转化流程图👇

![构建DOM树](C:\Users\姜嘿嘿\Desktop\imgs\构建DOM树.png)

大致过程：

1. `转换`：浏览器从缓存或网络拿到`html`的原始字节，并根据文件的指定编码(如UTF-8)将原始字节转化为字符。

2. `令牌化`：浏览器将字符转化为`w3c html 标准`的各个令牌。

3. `词法分析`：将令牌转换对象，对象中包含自己的属性和规则。

4. `DOM树构建`：将对象链接成一个树形结构，对象就成了树的节点，体现了节点之间的父子关系。

### 样式计算

三个步骤👇

1. 格式化样式表
2. 标准化样式表
3. 计算每个DOM节点的具体样式

**格式化样式表**

浏览器拿到的是`0`、`1`这样的字节流数据，浏览器无法直接识别，需要转化为`styleSheet`

通过`document.styleSheets`来查看最终结果👇

![格式化样式表](C:\Users\姜嘿嘿\Desktop\imgs\格式化样式表.png)

通过JavaScript可以完成查询和修改功能,或者说这个阶段为后面的样式操作提供基石。

**标准化样式表**

一段`css`代码

```css
body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
```

标准化👇

![标准化样式表](C:\Users\姜嘿嘿\Desktop\imgs\标准化样式表.png)

**计算每个DOM节点的具体样式**

计算规则：

- `继承`：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫`UserAgent`样式。

- `层叠`：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。

这个阶段，计算了DOM中每个节点的具体样式，并将结果保存到`window.getComputedStyle`中，可以通过js获取。

### 布局阶段(layout)

通过浏览器的布局系统确定元素的位置，生成布局树。

**创建布局树**

过程图👇

![创建布局树](C:\Users\姜嘿嘿\Desktop\imgs\创建布局树.png)

具体过程👇

1. 遍历DOM树的`可见节点`，将这些节点添加到布局树中

2. 对于不可见的节点、head、meta标签等都会被忽略。例如：对于`body.p.span` 这个元素，它的属性包含`display:none`，所以这个元素没有被包含进布局树。

**布局计算**

计算出布局树中各个节点的坐标位置。

### 分层

浏览器的页面实际上分成了很多图层，这些图层叠加后合成了最终的页面。

在完成布局后，还需要考虑元素层叠的情况。这个阶段就是解决这个问题的。

**生成图层树**

布局树和图层树的关系👇

![图层树](C:\Users\姜嘿嘿\Desktop\imgs\图层树.png)

如图，并不是每个节点都是一个单独的图层。如果一个节点没有对应的图层，那么这个节点就从属父节点的图层。

那么，为哪些节点创建新图层呢？

1. 拥有`层叠上下文`的节点

2. 需要裁剪的的节点

### 绘制

创建好图层树后，开始绘制。所谓绘制，会将一个复杂的图层拆分为很小的、一个个的绘制指令，然后按照这个绘制指令的顺序一个个进行绘制。

绘制操作是由专门的线程来完成的，这个线程叫`合成线程`。

类似于下图👇

![绘制](C:\Users\姜嘿嘿\Desktop\imgs\绘制.png)

绘制的具体步骤包括：

1. `分块`

2. `栅格化`

**分块**

> 有时候，一个图层可能很大，可能需要用到滚动条。这种情况下，用户只能通过视口看到一部分内容，如果直接绘制整个图层，会产生较大的开销，而且没有必要。所以需要将一个图层分为多个图块

**光栅化**

有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由`栅格化`来执行的。所谓`栅格化`，是指将图块转换为位图。

- 图块是栅格化执行的最小单位

- 渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据

- 合成线程会选择视口附近的图块(tile)，把它交给栅格化线程池生成位图

- 生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程

通常栅格化会使用`GPU`，渲染进程把生成图块的指令发送给 GPU进程，在`GPU`进程中生成位图，并保存在GPU内存中

如图👇

![光栅化](C:\Users\姜嘿嘿\Desktop\imgs\光栅化.png)

### 合成和显示

栅格化操作完成后，合成线程会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面。

## 重排重绘

### 重排

重排或者叫回流指的是，当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。

重排也叫回流，简单的说就是重新生成布局，重新排列元素。

重排会导致需要重新渲染DOM树，在渲染流程中就是从生成DOM树开始，将后面的流程全部走一遍。如下图👇

![重排](C:\Users\姜嘿嘿\Desktop\imgs\重排.png)

**以下情况会触发重排**

- 页面初始渲染，这是开销最大的一次重排

- 添加/删除可见的DOM元素

- 改变元素位置，如`left`、`top`等

- 改变元素尺寸，比如`width`、`padding`、`margin`等

- 改变元素内容，比如文字数量，图片大小等

- 改变元素字体大小

- 改变浏览器窗口尺寸，比如resize事件发生时

- 激活CSS伪类（例如：:hover）

- 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow

- 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。

**导致重排的属性和方法**

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`

- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`

- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`

- `scrollIntoView()`、`scrollIntoViewIfNeeded()`

- `getComputedStyle`()

- `getBoundingClientRect`()

- `scrollTo`()

### 重绘

当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。

由于没有导致元素的几何属性变化，从而省去了布局。具体流程如下：

![重排](C:\Users\姜嘿嘿\Desktop\imgs\重绘.png)

跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作。

可以看出，重绘不一定导致重排，但重排一定发生了重绘。

**引起重绘的属性**

- `color`	`border-style`	`visibility`	`background`等

### 优化

**减少重排的次数**

1. 样式集中改变：当需要改变样式时，相较每次微小修改都直接触及元素，更好的办法是统一在 cssText 变量中编辑。

```js
// bad
var left = 10;
var top = 10;
el.style.left = left + "px";
el.style.top = top + "px";

// 当top和left的值是动态计算而成时...
// better 
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";

// better
el.className += " className";
```

2. 分离读写操作: DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。

```js
// bad 强制刷新 触发四次重排+重绘
div.style.left = div.offsetLeft + 1 + 'px';
div.style.top = div.offsetTop + 1 + 'px';
div.style.right = div.offsetRight + 1 + 'px';
div.style.bottom = div.offsetBottom + 1 + 'px';


// good 缓存布局信息 相当于读写分离 触发一次重排+重绘
var curLeft = div.offsetLeft;
var curTop = div.offsetTop;
var curRight = div.offsetRight;
var curBottom = div.offsetBottom;

div.style.left = curLeft + 1 + 'px';
div.style.top = curTop + 1 + 'px';
div.style.right = curRight + 1 + 'px';
div.style.bottom = curBottom + 1 + 'px';
```

3. 对于 resize、scroll 等进行防抖/节流处理

**减少重排的范围**

## 浏览器事件模型

### 1.事件传播

```html
<body>
	<div class="outer">
		<div class="inner"></div>
	</div>
</body>
```

当我们点击inner元素
步骤1：点击事件传播途径：body -> outer -> inner。从外到里，称为事件捕获
步骤2：点击事件传播途径：inner -> outer -> body。从里到外，称为事件冒泡

### 2.DOM事件流

DOM2级事件流包括3个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段
**ie8及以下不支持**

### 3.取消事件捕获/冒泡

利用`event.stopPropagation()`方法

```js
let outer = document.querySelector('.outer')
let inner = document.querySelector('.inner')

outer.addEventListener('click', (e) => {
	console.log('outer')
	e.stopPropagation()
})

inner.addEventListener('click', (e) => {
	console.log('inner')
	e.stopPropagation()
})
```

### 4.事件委托/代理

将事件绑定到父类元素上，而不是所有子类元素。
利用`event.target`实现

```js
let ul = document.querySelectorAll('ul')[0]
ul.addEventListener('click', (e) => {
	console.log(e.target.innerHTML)
})
```

事件代理的好处：
1. 只用给一个元素监听事件，减少内存的使用
2. 当动态增加或删除节点时，不用手动重新监听事件

## 浏览器客户端存储

### 1.LocalStorage

localStorage存储在客户端，并且没有过期时间设置，除非主动删除否则不会过期

### 2.SessionStorage

sessionStorage存储在客户端，会话结束（关闭页面）时，数据清除

### 3.Cookie

浏览器发送HTTP请求时，先检查是否有相应的Cookie，如果有则将Cookie放在请求头中的Cookie字段中发送

#### 3.1 相关属性

1. `expires`：设置Cookie过期时间
2. `secure`：设为true时只能使用https
3. `httpOnly`：
4. domain和path：限制cookie能被哪些url访问
5. SameSite

#### 3.2 Cookie封装

```js
const cookieUtil = {
	setItem(key, value, days) {
		let date = new Date()
		date.setDate(date.getDate() + days)
		document.cookie = `${key}=${value};expires=${date}`
	},
	getItem(key) {
		let cookies = document.cookie.split(';')
		let ret
		cookies.forEach(item => {
			let tempArr = item.split('=')
			if (tempArr[0] === key) {
				ret = tempArr[1]
			}
		})
		return ret
	},
	removeItem(key) {
		this.setItem(key, null, -1)
	}
}
```

#### 3.3 Cookie和Storage的对比

1. Cookie存放数据小，4kb左右。而Storage可以存放5MB左右
2. Cookie可以设置过期时间，sessionStorage在关闭页面自动过期，localStorage必须手动清除
3. Cookie参与服务器通信，storage一般不用
4. 每次请求同意域名都会在请求头带上所有cookie，过多的cookie造成性能浪费

### 4.Session

通常使用Cookie时，会话数据都存在Cookie中。使用Session时，Cookie中只存放一个Session_id，会话数据放在服务端的内存或数据库中

![session](https://pic3.zhimg.com/v2-b4c952a1f71313670b94898b2bea4f6a_r.jpg)

### 5.JWT

## history路由和hash路由

**为什么使用前端路由？**

单页面应用利用了JavaScript动态变换网页内容，避免了页面重载；前端路由则提供了随着浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。

### hash路由

> 使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。

hash特性👇

1. url中hash值的变化并不会重新加载页面，因为hash是用来指导浏览器行为的，对服务端是无用的，所以不会包括在http请求中。

2. hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换。

3. 我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理。

**触发hashchange事件的几种情况**

1. 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件。

2. 当浏览器地址栏中URL包含哈希如 http://www.baidu.com/#home，这时按下输入，浏览器发送http://www.baidu.com/请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件。

3. `<a>`标签

```html
<a href="#test">to somewhere</a>
```

4. 直接赋值给`location.hash`

```js
location.hash = '#jhh'
```

### history路由

**概述**

- window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。
- History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。
- 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。
- 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。

**History对象的属性**

- `history.length`: 当前窗口访问过的网址数量

- `history.state`: History 堆栈最上层的状态值

**History对象的方法**

- `History.back()`：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。

- `History.forward()`：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果
。
- `History.go()`：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。

```js
history.back();
history.forward();
history.go(1);//相当于history.forward()
history.go(-1);//相当于history.back()
history.go(0); // 刷新当前页面
```

**History.pushState**

用于在历史中添加一条记录。但是不会触发页面刷新，只是导致`History`对象发生变化，地址栏有变化

```js
history.pushState(state, title, url)
```

- state : 一个于指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null。

- title : 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。

- url : 新的网址，必须与前页面处在同一个域。浏览器的地址栏将显示这个网址。


**History.replaceState**

替换当前的历史记录，不刷新页面

```js
history.replaceState(state, title, url)
```

- 用法和`pushState`一致
- `replaceState`是替换当前历史记录而不是添加

**popstate 事件**

每当`History`发生变化时，都会触发`popstate`事件

- 仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件。

- 只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、 History.go()方法时才会触发。

- 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。

- 页面第一次加载的时候，浏览器不会触发popstate事件。












