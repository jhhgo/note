# 状态码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作

## 状态码类别

### 2xx 请求正常处理完毕

1. 200 OK 客户端发来的请求在服务器端正常处理
2. 204 No Content 服务器成功处理了客户端请求，但服务器无返回内容。204的响应中没有body，而且Content-Length=0。204状态在一些网站分析的代码中最常用到，只需要把客户端的一些信息提交给服务器而无需关心响应。比如`options`请求
3. 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内

### 3xx重定向

1. 301 Moved Permanently 永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存
2. 302 Found 临时性重定向 该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问
3. 304 用于浏览器缓存

### 4xx客户端错误

1. 401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息
2. 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了
3. 404 Not Found 该状态码表明服务器上无法找到请求的资源

### 5xx服务端错误

# HTTP请求方法

| 方法   | 描述                                                         |
| :----- | ------------------------------------------------------------ |
| Get    | 通常用于请求资源                                             |
| Post   | 通常用于向服务端发送资源                                     |
| Delete | 通常用于删除资源                                             |
| Put    | 通常用于资源的更新，若资源不存在则新建一个                   |
| Option | 通常用于CORS的请求预检                                       |
| Head   | 只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源 |

## 幂等

> 一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下， GET ， HEAD ， PUT 和 DELETE  等方法都是幂等的，而  POST  方法不是。所有的 safe 方法也都是幂等的。



## Get/Post区别

- Get请求参数放在url中，Post请求参数放在实体里
- Get请求比Post请求更不安全，因为参数放在url中，不能用来传递敏感信息
- Get请求参数放在url中，所以有长度限制，Post则没有

## RESTful API

# HTTP头部

## 请求头部

- `Accept`: 可通知服务器，浏览器能够处理的媒体类型及媒体类型的相对优先级。

```js
// 文本文件：text/html、text/plain、text/css
// 图片文件：image/jpeg、image/gif、image/png
// 应用程序使用的二进制文件：application/octet-stream、application/zip
// q可以给媒体类型添加优先级范围是0~1，支持小数。默认为1.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.8
```

- `Accept-Charset`: 用来通知服务器浏览器支持的字符集及字符集的相对优先顺序。

```js
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
```

- `Authorization`: 用来告知服务器，用户代理的认证信息（证书值）。

- `host`:  用于虚拟主机。http1.1规定，必须包含这个请求头

- `If-Match`：协商缓存，值为etag

- `If-Modified-Since`

- `If-None-Match`

## 通用头部

| accept |      |
| ------ | ---- |
|        |      |
|        |      |
|        |      |



## 响应头部

- `Etag`:  资源的唯一标识
- `Location`:  Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。发生重定向时，向客户端返回要访问的url。配合301 、302状态码。

```js
Location: http://www.baidu.com/sample.html
```

- `Server`: 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。

```js
Server: Apache/2.2.17 (Unix)
```

# HTTP(Hypertext transfer protocol)

超文本传输协议。

## HTTP0.9/HTTP1.0

**HTTP 0.9**

HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 `GET` 方法。

**HTTP 1.0**

- 有了`Content-type`任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。

- 除了GET命令，还引入了POST命令和HEAD命令。

- 增加了请求头`header`，http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。

- 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。

缺陷：每请求一个资源都要新建一个TCP链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。

## HTTP1.1比起HTTP1.0

> HTTP/1.1 主要解决了HTTP 1.0的网络性能的问题，以及增加了一些新的东西

1. HTTP1.0默认不开启持久连接，HTTP1.1默认开启（Connection：Keep-Alive），并且支持管线化（Pipeline），不用等待响应亦可直接发送下一个请求。

2. HTTP1.0不支持Host头部，HTTP1.1支持，可以实现虚拟主机，因为多个域名可能解析到同一个IP上。

3. HTTP1.1比1.0新加了E-tag，If-None-Match，Cache-control等用于缓存控制的头部。

4. HTTP1.1新增24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突。

5. HTTP1.1对带宽进行优化。

## HTTP2.0比起HTTP1.1

1. HTTP2.0采用二进制格式传输，取代了HTTP1.x的文本格式传输，增加了数据传输的效率。

2. 多路复用。在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream），帧代表最小的数据单位，每个帧会标识出帧属于哪个流，流是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能

3. 头部压缩。对头部进行压缩，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。利用到了`HPACK`算法。

4. 服务器端Push（serve push）。服务器端预测某些客户端一定会请求的资源，并且提前主动推送给客户端。可以相对减少一点延迟时间。

**HTTP 1.1 管线化与HTTP 2.0 多路复用的区别**

![管线化与多路复用](C:\Users\姜嘿嘿\Desktop\imgs\管线化与多路复用.png)

- 第一钟请求方式，http1.0，单次发送1个request，必须在收到response后才能继续发请求。

- 第二种，http1.1 管线化，发送第一个请求后不必等待响应即可发送第二个请求。

- 基于第二种请求方式存在的问题，虽然不必等待前一个请求返回后才能发送下一个。但是在接收response时，必须按顺序接收如果前一个请求遇到了阻塞，后面的请求即使已经处理完毕了，仍然需要等待阻塞的请求处理完毕。这也就是`队头阻塞`

- 最后一种,http 2.0多路复用。一个tcp连接可以同时发送多个请求，每个请求中的数据（帧）标识了属于哪个请求，这样不必按发生请求的顺序接收响应。即使一个请求被阻塞了，也不会影响其他请求。

**HPACK算法**

![HPACK](C:\Users\姜嘿嘿\Desktop\imgs\HPACK.png)

在客户端和服务端都维护了一份索引表，表里定义了常用的http header。这样在请求时不必发送具体的http header，只需要发送在表里的索引位置即可。

## HTTP3.0

**HTTP3.0是啥？**

HTTP3.0是谷歌推出的新版本的HTTP协议。HTTP3.0弃用了TCP协议，转而使用一个基于UDP协议的QUIC协议。

![HTTP3.0](C:\Users\姜嘿嘿\Desktop\imgs\HTTP3.0.png)

## QUIC协议概览

**TCP协议的痛点**

- `多次握手`：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点
- `队头阻塞`：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被递交给应用层去处理。
- `无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK`：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制
- `无法进行连接迁移`：一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。

**QUIC的优点**

- 更好的连接建立方式
- 更好的拥塞控制
- 没有队头阻塞的多路复用
- 前向纠错
- 连接迁移

## QUIC协议详解

**没有队头阻塞的多路复用**

QUIC 的多路复用和 HTTP2 类似，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)

但是QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。

**0RTT建链**

首次连接：使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换。

1. 客户端请求建立连接
2. 服务端发送公钥
3. 客户端利用服务端公钥和本地生成的私钥，生成加密用的密钥
4. 客户端使用密钥加密数据传递给服务端

非首次连接：


# HTTPS的原理

HTTPS = HTTP + SSL/TLS，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密，用HTTP对加密后的数据进行传输。👇

![https](C:\Users\姜嘿嘿\Desktop\imgs\https.png)

HTTPS为了兼顾安全与效率，同时使用了对称加密和不对称加密。对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输

**与http的区别**

- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。
- HTTPS标准端口443，HTTP标准端口80。HTTPS需要用到SSL证书，而HTTP不用。

**主要作用**

- 数据加密：对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全

- 身份认证：通信双方验证对方的身份真实性

## 对称加密

加密和解密用同一个秘钥的加密方式叫做对称加密。

如果使用对称加密，那么对称加密的密钥如何传输？使用http传输密钥的话，如果被中间人拦截，也会导致密钥泄露。

## 非对称加密

- 非对称加密存在一对密钥，称为私钥和公钥。

- 公钥和私钥都能进行数据加密和解密，公钥能解密私钥加密的数据，私钥也能解密公钥加密的数据。

- 公钥是公开的，可以发送给任何客户端，而私钥只保存在服务器端。

## TLS握手过程

![TLS握手过程](C:\Users\姜嘿嘿\Desktop\imgs\tls握手过程.png)

1. Client发起一个HTTPS请求，连接443端口。这个过程可以理解成是请求公钥的过程。

2. Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。

3. 浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。

4. 在安全拿到「服务器公钥」后，客户端Client随机生成一个「对称密钥」，使用「服务器公钥」（证书的公钥）加密这个「对称密钥」，发送给Server(服务器)。

5. Server(服务器)通过自己的私钥，对信息解密，至此得到了「对称密钥」，此时两者都拥有了相同的「对称密钥」。

**中间人攻击**

在上诉第3步中，如何确保客户端收到的公钥，确实是服务端发送的公钥呢？解决办法是第三方认证。

先看看中间人攻击的过程👇

![中间人](C:\Users\姜嘿嘿\Desktop\imgs\中间人.png)

**第三方认证**

数字证书认证机构(CA)利用自己的私钥对服务端网站信息进行加密形成数字签名，将数字签名和服务端公钥一起作为数字证书。

首先浏览器会安装一些权威的第三方认证机构的公钥。

然后再收到数字证书时，利用公钥对加密后的数字签名进行解密，得到数字签名的明文。

然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。
## 传输细节

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3.  服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

# HTTP缓存

HTTP缓存分为强制缓存和协商缓存

## 浏览器请求资源过程

1. 先判断有没有缓存，如果没有则向服务器请求
2. 如果有，根据`Cache-Control`或`Expires`判断资源是否过期
	1. 如果没有过期，则直接从缓存读取（强制缓存），此时在Network一栏可以看到资源对应的状态码为200（from disk cache）或者是 200 （from memory cache）。比如，资源没过期的时候我们打开新的页面，资源会从硬盘缓存中读取（from disk cache）；如果我们此时又刷新页面，资源会从内存缓存中读取（from memory cache）
	2. 如果资源过期
		1. 查看上次资源的响应是否有Etag头部，如果有，发送`If-None-Match`请求
		2. 没有Etag的话，看上次资源的响应是否有Last-Modified，有的话发送请求，请求头为If-Modified-Since
		3. 如果命中了缓存，或者说资源没有发生改变，服务器会发送状态码为**304（Not Modify）**的响应，告诉浏览器读取缓存中的资源。
		4. 如果未命中缓存，或者说资源发生了改变，服务器会发送状态码为**200（OK）**的响应，并把资源作为响应的内容发送给浏览器

![缓存机制](C:\Users\姜嘿嘿\Desktop\http缓存机制.jpg)		
		


## 强缓存

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。

强缓存是利用http响应头中的`Expires`和`Cache-Control`两个字段来控制的，用来表示资源的缓存时间。其中`Cache-Control`的优先级比`Expires`高。

`Expires`: Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间（具体的某年某月某日时分秒），即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。

Cache-Control：
- max-age：缓存最大时间，单位秒。缓存内容将在这之后失效。

## 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

**Etag和If-None-Match**

- `Etag`：Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。

- `If-None-Match`：If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。

器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

**Last-Modified和If-Modify-Since**

- `Last-Modified`是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。

- `If-Modified-Since`则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。

服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

# TCP

TCP（Transmission Control Protocol），又叫传输控制协议。TCP协议是面向连接的，可靠的，基于字节流的传输协议。在基于 TCP 进行通信时，通信双方需要先建立一个 TCP 连接，建立连接需要经过三次握手，断开连接的时候需要经过四次挥手

## TCP报文结构

![TCP报文结构](C:\Users\姜嘿嘿\Desktop\tcp报文.png)

- 32bit的序号字段：用来标识包的序号，解决网络包乱序

- 32bit的确认好字段：ACK，用于确认收到，解决丢包

- 

## 三次握手

1. 第一次握手
	- SYN=1，seq=x
	- 客户端向服务端发送连接请求报文段，包含数据通讯初始序号（seq）
	- Server知道自己能接收到Client发送的报文

2. 第二次握手
	- SYN=1，ACK=1，ack=x+1，seq=y
	- 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号（seq）
	- client知道自己能接收Server发送的报文，知道自己发送的报文能被Server接收

3. 第三次握手
	- ACK=1，ack=y+1
	- 客户端收到连接同意的应答后，还要向服务端发送一个确认报文
	- Server知道自己发送的报文能被Client接收

### 为什么不两次握手

> 主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误

假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。 而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 为什么不四次握手

> 三次足够了，四次就是浪费资源

## 四次挥手

> TCP是全双工的，在断开连接时两端都需要发送FIN和ACK

1. 第一次挥手
	- 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求
	- FIN=1，seq=x

2. 第二次挥手
	- B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP连接时双向的，所以 B 仍旧可以发送数据给 A
	- ACK=1，ack=x+1

3. 第三次挥手
	- B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入LAST-ACK状态。
	  PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送
	- FIN=1，seq=y

4. 第四次挥手
	- A 收到释放请求后，向 B 发送确认应答
	- ACK=1，ack=y+1

  > 由于在客户端要关闭TCP连接的时候，服务端可能还在发送数据；所以服务端先进行第二次挥手，这个报文的作用是服务端不再接收数据；当服务端的数据全部发送过去后，再一次挥手，这样服务端就不再发送数据了；至此，TCP连接就关闭了

## TCP如何实现可靠数据传输？

考虑在传输过程中存在的问题：

1. 丢包问题。
2. 丢包后如何解决。
3. 文件顺序。文件按顺序发送，接收端需要按顺序接收，以还原文件。如果产生丢包，顺序怎么保证。


如何解决？

1. `肯定确认`：针对第一个问题，发送方需要知道接收方是否已经收到数据。所以接收方在接收到数据后，会向发送方发送一个ack报文。

2. `选择重传`：当发生丢包时，发送方仅重传哪些它怀疑在接收方出错的分组而避免了不必要的重传。

3. `缓存`：发送方有一块发送缓存，接收方有一块接收缓存。假设3个包按顺序分别是1 2 3 。2在传输过程中发生了丢包，然后3先到达，此时将3缓存。等待2到达，在把1 2 3一起向上交付

### 实现可靠数据传输的原理

**差错检测**

**重传**

快速重传：如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。

例子：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。👇

![快速重传](C:\Users\姜嘿嘿\Desktop\imgs\快速重传.png)

选择重传：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。

![选择重传](C:\Users\姜嘿嘿\Desktop\imgs\选择重传.png)

简单来讲就是在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了。

**累计确认**

**定时器**

发送方，发送数据时，会启动一个定时器，如果超时，会重传。

## TCP拥塞控制

> 发送方会根据所感知到的网络拥塞程度来限制其向连接发送流量的速率。

**如何限制向连接发送流量？**

答：发送方维护了一个变量--拥塞窗口，它对一个TCP发送方能向网络中发送流量的速率进行了限制。

### TCP拥塞控制算法

**慢启动**

开始时，拥塞窗口被设置为1个MSS(最大报文段长度)，每当传输的报文段首次被确认，就会增加1个MSS。

何时停止增长？如果产生了一个超时的丢包事件，此时会设置一个变量慢启动阈值为此时拥塞窗口值的一般。然后进入拥塞避免

**拥塞避免**

当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。	

**快速恢复**

# UDP

## UDP报文结构

报文结构如图👇

![UDP](C:\Users\姜嘿嘿\Desktop\imgs\udp报文结构.png)

- 源端口： 源端口号，需要对方回信时选用，不需要时全部置0.
- 目的端口：目的端口号，在终点交付报文的时候需要用到。
- 长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）
- 校验和：检测UDP数据报在传输中是否有错，有错则丢弃

## UDP的优势

- 无须建立连接：不同于TCP开始传输数据之前需要三次握手，UDP不需要任何准备即可进行数据传输。因此UDP没有建立连接的时延

- 无连接状态：TCP需要在端系统中维护连接状态包括：接收和发送缓存、序号、确认号等，用于实现可靠数据传输、拥塞控制。UDP不用维护这些数据。

- UDP报文小

# 输入URL之后会发生什么

1. 浏览器解析URL获取协议、域名、端口、路径

2. 查看浏览器是否有资源的缓存
	- 有。判断是否过期
		- 没过期，200，从缓存中读取
		- 过期
			1. Etag和If-None-Match
			2. Last-Modify和If-Modify-Since
			3. 文件修改了则服务器把新文件发送给客户端（200），没有修改则告诉客户端从缓存读取（304）

	- 没有则进行下一步
	
3. 进行DNS解析
	1. 浏览器缓存
	2. 本机缓存
	3. hosts文件
	4. 路由器缓存
	5. ISP DNS缓存
	6. DNS查询（递归查询/迭代查询）

4. 建立TCP连接
	- 客户端发送 SYN=1，req=x 请求报文
	- 服务端发送 ACK=1，ack=x+1，req=y 响应报文
	- 客户端发送 ACK=1，ack=y+1

5. TCP连接建立后发送HTTP请求
6. 对TCP报文打包，加入源IP地址和目标IP地址
7. 根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址
8. 对IP报文打包兵附上MAC地址
9. 发送数据，服务端收到请求并返回响应
10. 浏览器收到HTTP响应报文，关闭TCP连接或保持复用
11. （如果返回了HTML）根据响应头的字符集进行解码
12. 如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。
13. 资源预解析，会将一些请求资源提前加入请求队列中
14. 浏览器渲染

# DNS

> DNS（Domain Name System，域名系统），提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。

## 查询过程

1. 浏览器是否有缓存
2. 操作系统是否有缓存
3. 本地hosts文件是否有缓存
4. 本地DNS服务器是否有缓存
5. 向根域名服务器查询，如果有IP地址返回IP，否则给出顶级域名服务器IP地址让本地DNS服务器去查询
6. 继续给出下一级域名服务器IP地址让DNS服务器查询。迭代。。直到找到IP地址

## 递归

> 主机向本地域名服务器的查询一般都是采用递归查询。如果主机询问的本地DNS服务器不知道被查询域名的IP地址，则让本地DNS服务器作为DNS客户向其他根域名服务器发出查询请求报文
> 主机 <=> 本地DNS服务器 <=> 根域名服务器

## 迭代

> 本地DNS服务器向根域名服务器的查询。根域名服务器接收到本地DNS服务器的查询请求报文，要么给出IP地址，要么给出应该去查询的域名服务器的IP地址

# CDN

> CDN（Content Delivery Network，内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络，通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。

## 加速原理

> 当用户访问使用CDN服务的网站时，本地DNS服务器通过CNAME方式将最终域名请求重定向到CDN服务。CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的CDN节点IP地址提供给用户，使用户可以以最快的速度获得网站内容。使用CDN后的HTTP请求处理流程如下

![](C:\Users\姜嘿嘿\Desktop\cdn.png)

1. 用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求
2. 域名解析的请求被发往网站授权DNS服务器
3. 网站DNS服务器解析发现域名已经CNAME到了www.example.com.c.cdnhwc1.com
4. 请求被指向CDN服务
5. CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS
6. 用户获取响应速度最快的CDN节点IP地址
7. 浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求
8. CDN节点将用户所需资源返回给用户

![](C:\Users\姜嘿嘿\Desktop\cdn无缓存.png)






























