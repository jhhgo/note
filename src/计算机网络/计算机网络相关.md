# 状态码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端 的处理是否正常、通知出现的错误等工作

## 状态码类别

### 2xx 请求正常处理完毕

1. 200 OK 客户端发来的请求在服务器端正常处理
2. 204 No Content 服务器接收的请求已成功处理，但返回的响应报文中不含实体的主体部分
3. 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内

### 3xx重定向

1. 301 Moved Permanently 永久重定向
2. 302 Found 临时性重定向 该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问
3. 304 用于浏览器缓存

### 4xx客户端错误

1. 401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息
2. 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了
3. 404 Not Found 该状态码表明服务器上无法找到请求的资源

### 5xx服务端错误

# HTTP请求方法

| 方法   | 描述                                                         |
| :----- | ------------------------------------------------------------ |
| Get    | 通常用于请求资源                                             |
| Post   | 通常用于向服务端发送资源                                     |
| Delete | 通常用于删除资源                                             |
| Put    | 通常用于资源的更新，若资源不存在则新建一个                   |
| Option | 通常用于CORS的请求预检                                       |
| Head   | 只请求资源的头部，该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源 |

## Get/Post区别

- Get请求参数放在url中，Post请求参数放在实体里
- Get请求比Post请求更不安全，因为参数放在url中，不能用来传递敏感信息
- Get请求放在url中，所以有长度限制，Post则没有

## RESTful API

# HTTP头部

## 请求头部

| cookie            | 服务器接收到的cookie信息                                     |
| ----------------- | :----------------------------------------------------------- |
| host              | host字段是HTTP1.1新增的头部，主要用来实现虚拟主机            |
| If-None-Match     | 用于指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求 |
| If-Modified-Since | If-Modified-Since 字段指定的日期时间后，资源发生了 更新，服务器会接受请求 |

## 通用头部

| accept |      |
| ------ | ---- |
|        |      |
|        |      |
|        |      |



## 响应头部

| Set-Cookie                       | 告诉客户端使用的cookie信息。属性：expires、domain、secure、httpOnly |
| -------------------------------- | ------------------------------------------------------------ |
| Location                         | 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置 不同的资源。配合3xx状态码 |
| ETag                             | 首部字段 ETag 能告知客户端实体标识                           |
| Last-Modified                    | 首部字段 Last-Modified 指明资源最近一次修改的时间            |
|                                  |                                                              |
| expires                          | 资源失效的日期                                               |
| access-control-allow-origin      |                                                              |
| access-control-allow-credentials |                                                              |

# HTTP协议1.0，1.1，2.0的区别

## HTTP1.1比起HTTP1.0

1. HTTP1.0默认不开启持久连接，HTTP1.1默认开启（Connection：Keep-Alive），并且支持管线化（Pipeline），不用等待响应亦可直接发送下一个请求。
2. HTTP1.0不支持Host头部，HTTP1.1支持，可以实现虚拟主机。
3. HTTP1.1比1.0新加了E-tag，If-None-Match，Cache-control等用于缓存控制的头部。
4. HTTP1.1新增24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突。
5. HTTP1.1对带宽进行优化。

## HTTP2.0比起HTTP1.1

1. HTTP2.0采用二进制格式传输，取代了HTTP1.x的文本格式传输
2. 多路复用。在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream），帧代表最小的数据单位，每个帧会标识出帧属于哪个流，流是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能
3. 头部压缩。对头部进行压缩，并在两端维护索引表，后续就可以传输已经记录过的头部键名，对端在索引表中通过键名找到对应的值
4. 服务器端Push（serve push）。服务器端预测某些客户端一定会请求的资源，并且提前主动推送给客户端。可以相对减少一点延迟时间。

# HTTPS的原理

HTTPS = HTTP + SSL/TLS，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密，用HTTP对加密后的数据进行传输

HTTPS为了兼顾安全与效率，同时使用了对称加密和不对称加密。对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输

## 传输细节

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3.  服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

# HTTP缓存

HTTP缓存分为强制缓存和协商缓存

## 浏览器请求资源过程

1. 先判断有没有缓存，如果没有则向服务器请求
2. 如果有，根据`Cache-Control`或`Expires`判断资源是否过期
	1. 如果没有过期，则直接从缓存读取（强制缓存），此时在Network一栏可以看到资源对应的状态码为200（from disk cache）或者是 200 （from memory cache）。比如，资源没过期的时候我们打开新的页面，资源会从硬盘缓存中读取（from disk cache）；如果我们此时又刷新页面，资源会从内存缓存中读取（from memory cache）
	2. 如果资源过期
		1. 查看上次资源的响应是否有Etag头部，如果有，发送`If-None-Match`请求
		2. 没有Etag的话，看上次资源的响应是否有Last-Modified，有的话发送请求，请求头为If-Modified-Since
		3. 如果命中了缓存，或者说资源没有发生改变，服务器会发送状态码为**304（Not Modify）**的响应，告诉浏览器读取缓存中的资源。
		4. 如果未命中缓存，或者说资源发生了改变，服务器会发送状态码为**200（OK）**的响应，并把资源作为响应的内容发送给浏览器


![缓存机制](C:\Users\姜嘿嘿\Desktop\http缓存机制.jpg)		
		


## 强缓存

强缓存是利用http响应头中的`Expires`和`Cache-Control`两个字段来控制的，用来表示资源的缓存时间
Expires：设置一个绝对时间，表示在这个时间后，缓存失效
Cache-Control：
- max-age：缓存最大时间，单位秒

## 协商缓存

协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。

Etag和If-None-Match

Last-Modified和If-Modify-Since

# TCP

TCP（Transmission Control Protocol），又叫传输控制协议。TCP协议是面向连接的，可靠的，基于字节流的传输协议。在基于 TCP 进行通信时，通信双方需要先建立一个 TCP 连接，建立连接需要经过三次握手，断开连接的时候需要经过四次挥手

## TCP报文结构

![TCP报文结构](C:\Users\姜嘿嘿\Desktop\tcp报文.png)

## 三次握手

1. 第一次握手
	- SYN=1，seq=x
	- 客户端向服务端发送连接请求报文段，包含数据通讯初始序号（seq）
	- Server知道自己能接收到Client发送的报文

2. 第二次握手
	- SYN=1，ACK=1，ack=x+1，seq=y
	- 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号（seq）
	- client知道自己能接收Server发送的报文，知道自己发送的报文能被Server接收

3. 第三次握手
	- ACK=1，ack=y+1
	- 客户端收到连接同意的应答后，还要向服务端发送一个确认报文
	- Server知道自己发送的报文能被Client接收

### 为什么不两次握手

> 主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误

假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。 而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 为什么不四次握手

> 三次足够了，四次就是浪费资源

## 四次挥手

> TCP是全双工的，在断开连接时两端都需要发送FIN和ACK

1. 第一次挥手
	- 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求
	- FIN=1，seq=x

2. 第二次挥手
	- B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP连接时双向的，所以 B 仍旧可以发送数据给 A
	- ACK=1，ack=x+1

3. 第三次挥手
	- B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入LAST-ACK状态。
	  PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送
	- FIN=1，seq=y

4. 第四次挥手
	- A 收到释放请求后，向 B 发送确认应答
	- ACK=1，ack=y+1

### 为什么四次挥手

> 由于在客户端要关闭TCP连接的时候，服务端可能还在发送数据；所以服务端先进行第二次挥手，这个报文的作用是服务端不再接收数据；当服务端的数据全部发送过去后，再一次挥手，这样服务端就不再发送数据了；至此，TCP连接就关闭了

# 输入URL之后会发生什么

1. 浏览器解析URL获取协议、域名、端口、路径

2. 查看浏览器是否有资源的缓存
	- 有。判断是否过期
		- 没过期，200，从缓存中读取
		- 过期
			1. Etag和If-None-Match
			2. Last-Modify和If-Modify-Since
			3. 文件修改了则服务器把新文件发送给客户端（200），没有修改则告诉客户端从缓存读取（304）

	- 没有则进行下一步
	
3. 进行DNS解析
	1. 浏览器缓存
	2. 本机缓存
	3. hosts文件
	4. 路由器缓存
	5. ISP DNS缓存
	6. DNS查询（递归查询/迭代查询）

4. 建立TCP连接
	- 客户端发送 SYN=1，req=x 请求报文
	- 服务端发送 ACK=1，ack=x+1，req=y 响应报文
	- 客户端发送 ACK=1，ack=y+1

5. TCP连接建立后发送HTTP请求
6. 对TCP报文打包，加入源IP地址和目标IP地址
7. 根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址
8. 对IP报文打包兵附上MAC地址
9. 发送数据，服务端收到请求并返回响应
10. 浏览器收到HTTP响应报文，关闭TCP连接或保持复用
11. （如果返回了HTML）根据响应头的字符集进行解码
12. 如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。
13. 资源预解析，会将一些请求资源提前加入请求队列中
14. 浏览器渲染

# DNS

> DNS（Domain Name System，域名系统），将域名转化为IP地址

## 查询过程

1. 浏览器是否有缓存
2. 操作系统是否有缓存
3. 本地hosts文件是否有缓存
4. 本地DNS服务器是否有缓存
5. 向根域名服务器查询，如果有IP地址返回IP，否则给出顶级域名服务器IP地址让本地DNS服务器去查询
6. 继续给出下一级域名服务器IP地址让DNS服务器查询。迭代。。直到找到IP地址

## 递归

> 主机向本地域名服务器的查询一般都是采用递归查询。如果主机询问的本地DNS服务器不知道被查询域名的IP地址，则让本地DNS服务器作为DNS客户向其他根域名服务器发出查询请求报文
> 主机 <=> 本地DNS服务器 <=> 根域名服务器

## 迭代

> 本地DNS服务器向根域名服务器的查询。根域名服务器接收到本地DNS服务器的查询请求报文，要么给出IP地址，要么给出应该去查询的域名服务器的IP地址

# CDN

> CDN（Content Delivery Network，内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络，通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。

## 加速原理

> 当用户访问使用CDN服务的网站时，本地DNS服务器通过CNAME方式将最终域名请求重定向到CDN服务。CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的CDN节点IP地址提供给用户，使用户可以以最快的速度获得网站内容。使用CDN后的HTTP请求处理流程如下

![](C:\Users\姜嘿嘿\Desktop\cdn.png)

1. 用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求
2. 域名解析的请求被发往网站授权DNS服务器
3. 网站DNS服务器解析发现域名已经CNAME到了www.example.com.c.cdnhwc1.com
4. 请求被指向CDN服务
5. CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS
6. 用户获取响应速度最快的CDN节点IP地址
7. 浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求
8. CDN节点将用户所需资源返回给用户

![](C:\Users\姜嘿嘿\Desktop\cdn无缓存.png)






























